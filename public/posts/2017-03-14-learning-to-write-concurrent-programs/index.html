<!doctype html>





































<html
  class="not-ready lg:text-base"
  style="--bg: #f8f5d7"
  lang="en-gb"
  dir="ltr"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Learning to write concurrent programs - Saurabh Jha</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="I taught myself some concurrent programming lately. I did it as part of my
operating systems studies. In this essay, I will illustrate it using an
example problem.
I will be illustrating concurrent programming using operating system primitives.
[1] There are several different ways to do concurrent programming that does
not involve interacting with the operating system kernel. Even if we restrict
ourselves to using kernel primitives, there are many variants. I will
mainly be concerned with concurrency using mutexes and condition variables. In
literature, it is sometimes called concurrent programming using shared objects." />
  <meta name="author" content="Saurabh Jha" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://saurabhjha.github.io/main.min.css" />

  <link rel="stylesheet" as="style" href="/css/index.css">

  
  
  
  
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/theme.svg" />

  
  
  
  
  

  
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/github.svg" />
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/linkedin.svg" />
  
  

  
  
  <script
    defer
    src="https://saurabhjha.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  
  
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
  integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
  crossorigin="anonymous"
/>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
  integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
  crossorigin="anonymous"
></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
  integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
  crossorigin="anonymous"
></script>


<script>
  document.addEventListener('DOMContentLoaded', () =>
    renderMathInElement(document.body, {
      
      
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
      ],
      
      throwOnError: false,
    }),
  );
</script>

  
  
  

  
  <link
    rel="icon"
    href="https://saurabhjha.github.io/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="https://saurabhjha.github.io/apple-touch-icon.png"
  />

  
  <meta name="generator" content="Hugo 0.140.0">

  
  
  
  
  
  
  <meta itemprop="name" content="Learning to write concurrent programs">
  <meta itemprop="description" content="I taught myself some concurrent programming lately. I did it as part of my operating systems studies. In this essay, I will illustrate it using an example problem.
I will be illustrating concurrent programming using operating system primitives. [1] There are several different ways to do concurrent programming that does not involve interacting with the operating system kernel. Even if we restrict ourselves to using kernel primitives, there are many variants. I will mainly be concerned with concurrency using mutexes and condition variables. In literature, it is sometimes called concurrent programming using shared objects.">
  <meta itemprop="datePublished" content="2017-03-14T00:00:00+00:00">
  <meta itemprop="dateModified" content="2017-03-14T00:00:00+00:00">
  <meta itemprop="wordCount" content="3422">
  
  <meta property="og:url" content="https://saurabhjha.github.io/posts/2017-03-14-learning-to-write-concurrent-programs/">
  <meta property="og:site_name" content="Saurabh Jha">
  <meta property="og:title" content="Learning to write concurrent programs">
  <meta property="og:description" content="I taught myself some concurrent programming lately. I did it as part of my operating systems studies. In this essay, I will illustrate it using an example problem.
I will be illustrating concurrent programming using operating system primitives. [1] There are several different ways to do concurrent programming that does not involve interacting with the operating system kernel. Even if we restrict ourselves to using kernel primitives, there are many variants. I will mainly be concerned with concurrency using mutexes and condition variables. In literature, it is sometimes called concurrent programming using shared objects.">
  <meta property="og:locale" content="en_gb">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-03-14T00:00:00+00:00">
    <meta property="article:modified_time" content="2017-03-14T00:00:00+00:00">

  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Learning to write concurrent programs">
  <meta name="twitter:description" content="I taught myself some concurrent programming lately. I did it as part of my operating systems studies. In this essay, I will illustrate it using an example problem.
I will be illustrating concurrent programming using operating system primitives. [1] There are several different ways to do concurrent programming that does not involve interacting with the operating system kernel. Even if we restrict ourselves to using kernel primitives, there are many variants. I will mainly be concerned with concurrency using mutexes and condition variables. In literature, it is sometimes called concurrent programming using shared objects.">

  
  

  
  <link rel="canonical" href="https://saurabhjha.github.io/posts/2017-03-14-learning-to-write-concurrent-programs/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center">
  <div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center">
    <a class="-translate-y-[1px] text-2xl font-medium" href="https://saurabhjha.github.io/"
      >Saurabh Jha</a
    >
    <div
      class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#f8f5d7'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 rtl:space-x-reverse dark:invert ltr:lg:ml-14 rtl:lg:mr-14 lg:mt-0 lg:items-center"
    >
      
      <a
        class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/saurabhjha"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./linkedin.svg)"
        href="https://linkedin.com/in/saurabh-jha-51706349"
        target="_blank"
        rel="me"
      >
        linkedin
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100vh-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"
    >
      

<article>
  <header class="mb-14">
    <h1 class="!my-0 pb-2.5">Learning to write concurrent programs</h1>

    
    <div class="text-xs antialiased opacity-60">
      
      <time>Mar 14, 2017</time>
      
      
      
      
    </div>
    
  </header>

  <section><p>I taught myself some concurrent programming lately. I did it as part of my
operating systems studies. In this essay, I will illustrate it using an
example problem.</p>
<p>I will be illustrating concurrent programming using operating system primitives.
[1] There are several different ways to do concurrent programming that does
not involve interacting with the operating system kernel. Even if we restrict
ourselves to using kernel primitives, there are many variants. I will
mainly be concerned with concurrency using mutexes and condition variables. In
literature, it is sometimes called <em>concurrent programming using shared objects</em>.</p>
<h2 id="platform-details">Platform details</h2>
<p>I developed this program on a Vagrant VM using Virtualbox that ran FreeBSD 10.2.
Even though I have a lot more experience with Linux [2], I feel I am more
comfortable using FreeBSD, even though I don&rsquo;t have a lot of experience with it.
There are a couple of reasons.</p>
<ul>
<li>The documentation and man pages of FreeBSD are really good.</li>
<li>The kernel code of FreeBSD is more readable to me than that of Linux.</li>
</ul>
<h2 id="problem-definition">Problem definition</h2>
<p>I am choosing a contrived problem so that we can focus on concurrency,
without getting distracted by incidental details. The problem is this.</p>
<p>We have a fixed number of integers. Our objective is to calculate the Fibonacci
number of all these integers. [3] The constraint is, for each integer, we will
calculate the Fibonacci number exactly once.</p>
<h2 id="general-ideas-about-the-solution">General ideas about the solution</h2>
<p>We can solve this problem in many different ways. A straightforward
way is to put all the integers in an array, loop over the array, and calculate
all Fibonacci numbers. This is fine but we won&rsquo;t be taking advantage of multiple
cores. [4] If we can make our program concurrent using threads, it might
increase its throughput, the number of jobs processed per second.</p>
<p>Concurrent programming is hard because the data structures are shared between
multiple threads. We need to ensure that the threads access the shared data
structures safely without causing any inconsistency or corruption.</p>
<p>Since the shared data structure is the central problem here, we will tackle that
first. What data structure should we choose for this problem? Remember the
problem is we have got integers and each integer has to be processed exactly
once.</p>
<p>For this problem, we can use a simple circular queue. It will look like this.
We can have producer threads enqueuing the queue with integers and we can have
consumer threads dequeuing integers from queue and process it.</p>
<h2 id="sequential-solution">Sequential solution</h2>
<p>The struct for a sequential queue looks like this. [5][6]</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> queue {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* State variables */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>storage;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> front; <span style="color:#75715e">/* Front of the queue. Should have element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                  when queue has at least one. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rear; <span style="color:#75715e">/* Next free slot. Should not have element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                 unless the queue is full. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Of course, we will have problems with this <code>struct</code> if multiple threads access
it simultaneously. We will address this later.</p>
<p>The code that inserts and deletes elements from this queue, as well as mutates its
state variables, would look like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span><span style="color:#a6e22e">initialize_queue</span>(<span style="color:#66d9ef">int</span> queue_length)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Allocate memory for queue_object and queue_object-&gt;storage. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> queue_object;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">destruct_queue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Free memory of queue_object */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">enqueue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object, <span style="color:#66d9ef">int</span> element)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Try to insert element into queue_object. Return true on success and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       return false on failure. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dequeue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Remove the front element from the queue and return it. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> element;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_queue_full</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Returns a boolean indicating if the queue is filled up. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_queue_empty</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Returns a boolean indiciating if the queue is empty. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Now it is very important that all state changes happen inside these functions
and nowhere else. Its the responsibility of these functions to do insertion/deletion
of elements and do state changes (for example, changing front and rear properties) safely.
For simplicity, I will call these functions &ldquo;public functions&rdquo; from now on. [7]</p>
<p>Also, note that we have got two simple predicate functions, <code>is_queue_full</code> and
<code>is_queue_empty</code>. They will come in use in a bit.</p>
<h2 id="requirements-of-concurrency">Requirements of concurrency</h2>
<p>The requirements of concurrency are as follows. We will refine these as we go
along.</p>
<ul>
<li>Only one thread can execute a public function at a time.</li>
<li>If a currently running thread can&rsquo;t make progress with a public function, it
must allow other threads to make progress with that function.</li>
<li>If a thread is waiting for some condition to become true, we must be able to
notify that sleeping thread when that condition holds true.</li>
</ul>
<h2 id="thread-basics">Thread basics</h2>
<p>First, we will look at how to create and manipulate threads. The standard
function to create a thread in C is <code>pthread_create</code>. It is used like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">pthread_create</span>(<span style="color:#f92672">&amp;</span>thread_id, <span style="color:#f92672">&amp;</span>thread_attr, thread_routine, thread_arg);</span></span></code></pre></div>
<p>Here, <code>thread_id</code> is a variable of type <code>pthread_t</code>, <code>thread_attr</code> is a
variable of type <code>pthread_attr_t</code>, <code>thread_routine</code> is a function that
takes an argument of type <code>void *</code> and returns <code>void *</code> and <code>thread_arg</code>
is a variable of type <code>void *</code> that is passed to <code>thread_routine</code> function.</p>
<p>Let&rsquo;s take an example. Suppose we want to execute a function <code>fib</code> in a
separate thread. The declaration of <code>fib</code> looks like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> n);</span></span></code></pre></div>
<p>Suppose we want to calculate <code>fib(3)</code>. We will call it in a separate thread
like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pthread_t</span> some_thread_id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_create</span>(<span style="color:#f92672">&amp;</span>some_thread_id, NULL, fib, <span style="color:#ae81ff">3</span>);</span></span></code></pre></div>
<p>Notice that the second argument, which was supposed to be a <code>thread_attr</code>, is
NULL. This is what we do when we want default attributes. Also, notice that the
<code>pthread_create</code> spec said that we should use a function that takes a <code>void *</code> and
returns a <code>void *</code> and I am instead passing a function that takes an <code>int</code> and
returns an <code>int</code>. I want to keep things simple and I am relying on the compiler
to do the type coercions for me. In my experience, these particular coercions
are safe and do not lead to any corruption or information loss.
The same holds for the fourth argument <code>thread_arg</code>.</p>
<p>Suppose in our <code>main</code> function, we create a thread that executes <code>fib</code>.
It will look like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span> random_thread_id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span>(<span style="color:#f92672">&amp;</span>random_thread_id, NULL, fib, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>The problem is <code>main</code> can return before the thread finishes execution. To
<em>wait</em> for the current thread to finish, we use the function <code>thread_join</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span> random_thread_id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span>(<span style="color:#f92672">&amp;</span>random_thread_id, NULL, fib, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_join</span>(random_thread_id);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><code>pthread_join</code> returns immediately if the thread has finished its execution.
Otherwise, it will block till the thread finishes, and then it will return. By
induction, if you create n separate threads, you can wait for all n of them to
complete by doing <code>pthread_join</code> on all the thread_ids. This is what I did for
all producer and consumer threads.</p>
<p>There is no guarantee that a thread created by <code>pthread_create</code> will start
immediately. Whenever we call <code>pthread_create</code>, the operating system puts the
thread into something called the <strong>ready list</strong> of the schedular. The kernel
schedular then picks up a thread to run from the ready list based on some
scheduling policy. So, <code>pthread_create</code> creates a thread and puts it into the
ready list to be run later.</p>
<h2 id="making-queue-concurrent">Making queue concurrent</h2>
<p>Now let&rsquo;s get back to our <code>queue</code> struct. We want to make do some changes so that
this data structure can be used by multiple threads safely. Let&rsquo;s revisit our
criteria for concurrency.</p>
<ol>
<li>Mutual exclusion: Only one thread can change the state of the queue at a
time.</li>
<li>Wait if we can&rsquo;t progress: If a thread can&rsquo;t progress, it must allow other
threads to make progress.</li>
<li>Notify waiting threads: If something happens that allows waiting threads
to make progress, we should be able to notify them.</li>
</ol>
<p>Now let&rsquo;s discuss these requirements in more detail and implement them.</p>
<h3 id="mutual-exclusion">Mutual exclusion</h3>
<p>The primitive that provides mutual exclusion is called the <strong>mutex</strong>. Its a variable
of type <code>pthread_mutex_t</code>. We will consider two functions that operate on mutexes.
These are <code>pthread_mutex_lock</code> and <code>pthread_mutex_unlock</code>. They are used like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pthread_mutex_t</span> my_mutex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>my_mutex);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Some code */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>my_mutex);</span></span></code></pre></div>
<p>Now, <code>/* Some code */</code> can only be executed by that one thread who has called
<code>pthread_mutex_lock</code> and hasn&rsquo;t called <code>pthread_mutex_unlock</code> yet. If a thread
calls <code>pthread_mutex_lock</code> while another thread is still using it, the thread
is stopped and put into a waitlist associated with <code>my_mutex</code>. Once <code>my_mutex</code>
becomes free, one thread is popped from the waitlist of <code>my_mutex</code> and made
available to run by putting it back into the ready list.</p>
<p>Our queue struct will look like this now. We add a new field in <code>struct</code> called
<code>mutex</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> queue {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* State variables */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>storage;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> front; <span style="color:#75715e">/* Front of the queue. Should have element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                  when queue has at least one. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rear; <span style="color:#75715e">/* Next free slot. Should not have element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                 unless the queue is full. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Synchronization variables */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>mutex;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We have got functions that modify the state variables of the <code>queue</code>. They are
the <code>enqueue</code> and the <code>dequeue</code>. There is no state change outside of these functions.</p>
<p>So <strong>we acquire the lock at the beginning of these functions and release that at the
end</strong>. We modify our <code>enqueue</code> and <code>dequeue</code> functions like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">enqueue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object, <span style="color:#66d9ef">int</span> element)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Try to insert element into queue_object. Return true on success and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       return false on failure. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Insertion code */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dequeue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Remove the front element from the queue and return it. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Removal code */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> element;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This is where restricting state changes to these functions start paying off.
We only need to worry about mutual exclusion in these functions. Now it is
very important to note that <strong>we hold the lock at the beginning and release
the lock at the end of these functions</strong>. That is, don&rsquo;t acquire and release
the locks anywhere else in the code.</p>
<p>You might think that this is inefficient and coarse-grained. Or you might think
that holding locks like this will increase lock contention (&ldquo;It changes state
only in those three lines so let&rsquo;s just wrap those inside lock&rdquo;). The problem
with that approach is it makes it very hard to understand and modify existing
code safely. Furthermore, it is not inefficient and won&rsquo;t lead to lock
contention as we will see right now.</p>
<h3 id="wait-if-we-cant-make-progress">Wait if we can&rsquo;t make progress</h3>
<p>Suppose a thread is executing <code>enqueue</code> and finds that the queue is full. What
should we do here?</p>
<p>We should give up the mutex we are holding and go to the waiting state. The
object that helps us achieve this is called a <strong>condition variable</strong>.</p>
<p>Condition variables give us the mechanism to <strong>atomically release the lock
and go to the waiting state</strong>. A condition variable is a variable of type
<code>pthread_cond_t</code> Each condition variable has associated with it
a waitlist of threads.</p>
<p>We have a function, <code>pthread_cond_wait</code>, that takes a mutex and a condition variable
as arguments and releases the mutex and puts the running thread to the waitlist of the condition variable.
The greatest value provided by <code>pthread_cond_wait</code> is it does these two operations <em>atomically</em>.
So if we have code like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>code_cond_var;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>code_mutex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_cond_wait</span>(code_cond_var, code_mutex);</span></span></code></pre></div>
<p>The thread running this snippet will give up <code>code_mutex</code> and go to the
waitlist of <code>code_cond_var</code>.</p>
<p>When would we want to call <code>pthread_cond_wait</code>? We want to call it
whenever we can&rsquo;t make progress. Whenever we design a shared object and
deciding on condition variables, we ask this question: When can a thread
wait? For our problem, the answers will be:</p>
<ol>
<li>Whenever we are running <code>enqueue</code> and the queue is full.</li>
<li>Whenever we are running <code>dequeue</code> and the queue is empty.</li>
</ol>
<p>Based on that, we would need two condition variables <code>queue_has_space</code>
and <code>queue_has_element</code> for 1) and 2) respectively.</p>
<p>Our queue struct looks like this now.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> queue {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* State variables */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>storage;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> front; <span style="color:#75715e">/* Front of the queue. Should have element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                  when queue has at least one. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rear; <span style="color:#75715e">/* Next free slot. Should not have element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                 unless the queue is full. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Synchronization variables */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_mutex_t</span> <span style="color:#f92672">*</span>mutex;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>queue_has_space;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>queue_has_element;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We added two new fields of type <code>pthread_cond_t</code>: <code>queue_has_space</code> and
<code>queue_has_element</code>. Our state-changing functions look like this now.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">enqueue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object, <span style="color:#66d9ef">int</span> element)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Try to insert element into queue_object. Return true on success and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       return false on failure. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">is_queue_full</span>(queue_object)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_cond_wait</span>(queue_object<span style="color:#f92672">-&gt;</span>queue_has_space, queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Insertion code */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dequeue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Remove the front element from the queue and return it. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">is_queue_empty</span>(queue_object)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_cond_wait</span>(queue_object<span style="color:#f92672">-&gt;</span>queue_has_element, queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Removal code */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> element;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Let&rsquo;s look at <code>enqueue</code>. <code>pthread_cond_wait</code> atomically releases <code>queue_object-&gt;mutex</code> and go to the
waitlist of <code>queue_object-&gt;queue_has_space</code>. It won&rsquo;t return until we chose
to wake up the threads in the waiting list of <code>queue_object-&gt;queue_has_space</code>.
We will discuss how to wake up threads that are waiting in the next section.</p>
<p>Notice that we wrapped <code>pthread_cond_wait</code> calls inside a while loop. This is
important. <strong>We should always wait on a condition variable inside a while
loop</strong>. This is because if later, we return from pthread_cond_wait, there is no
guarantee that the current condition will still allow us to progress. Let&rsquo;s
consider an example.</p>
<p>Suppose we only have space for one element in our queue and we have got an
enqueue thread E1 and two dequeue threads D1 and D2. D1 runs first, sees that
there is no element to dequeue, releases the lock, and go to the waitlist.
Now, E1 acquires the lock and fills up the queue with one element. Suppose after that,
instead of D1, D2 runs and dequeues the thread and we switch to D1. Now, if
we have our <code>pthread_cond_wait</code> inside a <code>while</code> loop, we will check the
condition again and go to the waitlist. If instead, we had our
<code>pthread_cond_wait</code> call inside an <code>if</code> statement, we would have progressed
further and might have caused data corruption.</p>
<h3 id="notify-waiting-threads">Notify waiting threads</h3>
<p>Finally, we want to notify the threads in the waitlist of condition variables
if they can make progress. For example, after <code>dequeue</code>, there is a
chance that some <code>enqueue</code> thread was waiting for it. For this, we use a
function <code>pthread_cond_signal</code>. It wakes up <strong>one</strong> thread from the waitlist
of a condition variable and puts it into the ready list. [8] Again, as above,
there is no guarantee that the signaled thread will run immediately. It is put
into the ready list and its the scheduler&rsquo;s job to run it according to
scheduling policy. Its called like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>code_condvar;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_cond_signal</span>(code_condvar);</span></span></code></pre></div>
<p>Our <code>enqueue</code> and <code>dequeue</code> functions will look like this now.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">enqueue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object, <span style="color:#66d9ef">int</span> element)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Try to insert element into queue_object. Return true on success and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       return false on failure. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">is_queue_full</span>(queue_object)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_cond_wait</span>(queue_object<span style="color:#f92672">-&gt;</span>queue_has_space, queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Insertion code */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_cond_signal</span>(queue_object<span style="color:#f92672">-&gt;</span>queue_has_element);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dequeue</span>(<span style="color:#66d9ef">struct</span> queue <span style="color:#f92672">*</span>queue_object)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Remove the front element from the queue and return it. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">is_queue_empty</span>(queue_object)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_cond_wait</span>(queue_object<span style="color:#f92672">-&gt;</span>queue_has_element, queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Removal stuff */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_cond_signal</span>(queue_object<span style="color:#f92672">-&gt;</span>queue_has_space);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(queue_object<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> element;</span></span></code></pre></div>
<p>Concurrent programming has a reputation that we have to reason about the global
structure of the program. If we wrap our condition variable checks inside a
<code>while</code> loop as we did above, we avoid some of that. In our case,
<code>pthread_cond_signal</code> can be regarded as a <em>hint</em> for other threads to check if
they can run again.</p>
<p>Thus, we can liberally do <code>pthread_cond_signal</code> calls whenever we think we changed
something that might allow others to progress. We hope that others will check the condition
again on their end.</p>
<h2 id="general-remarks">General Remarks</h2>
<p>The full implementation can be found <a href="https://github.com/saurabhjha/bogus-queue">here</a>.</p>
<p>Thread programming using locks has got a bad reputation in recent years.
Especially for I/O concurrency, if you propose a solution that involves threads,
others would probably think you have gone nuts. Or maybe fire you while they are
at it.</p>
<p>However, I still think I would use threads even for I/O concurrency. The
reasons are</p>
<ol>
<li>I don&rsquo;t want to worry about thread scheduling. The kernel does it for me. It does it
better than me because it has got privileges I as a user program don&rsquo;t have.</li>
<li>I want my solution to work for any kind of I/O. Network I/O is not the only
kind of I/O, you know.</li>
<li>I want my solution to be portable across UNIX implementations. I don&rsquo;t want
to change my implementation from <code>epoll</code> to <code>kqueue</code>. [9]</li>
</ol>
<p>I think this whole sentiment of <em>threads sucks</em> originated from Dan Kegel&rsquo;s
landmark C10K paper. [10] It has been updated from time to time but I think the
kernel implementations have come a long way since then. For example, how much
do you think it costs to acquire an uncontended lock. It can be as fast as
10 instructions. In some implementations, it is as low as 2 instructions. [11]</p>
<p>What about processes? <code>fork</code> is definitely expensive right?
After all, you have to copy every open file for the child process. Well, in recent
Copy-On-Write (COW) implementations, [12] you don&rsquo;t even copy those.</p>
<p>It seems to me that despite all the modernity of developers (using the latest
frameworks, latest libraries, etc.), they are still programming using old ideas
about the platforms on which their applications run.</p>
<p>That&rsquo;s for I/O concurrency. For CPU concurrency, I don&rsquo;t think there is any
debate. Thread programming is the way to go.</p>
<p>However, these abstractions of mutexes and condition variables were developed
for operating system purposes. Are they suitable for application programs? I am
not sure. For example, Erlang doesn&rsquo;t use operating system threads or processes
and its model sounds promising. There have been successful
companies/projects built on it. I would love to learn Erlang and
maybe after that I will conclude that all these locks, condition variables, etc.
are not good abstractions for normal programs. Or maybe I will conclude that
there is a place for both kinds of abstractions. I am certainly looking forward
to that.</p>
<p>Incidentally, while I was writing this program, I spent much more time
implementing sequential queue then concurrency aspects. It is pretty clear to me
how much I suck in data structures and algorithms. In fact, until last year, I
used to think of algorithms as a topic that people study to crack job
interviews. Oh well, better late than never.</p>
<h2 id="further-reading">Further reading</h2>
<p>If you are interested, these are good books to learn more about the topics
covered here.</p>
<ol>
<li><a href="http://ospp.cs.washington.edu">Operating systems: Principles and Practice</a>
by Thomas Anderson and Michael Dahlin. Its a pretty recent book.</li>
<li><a href="http://www.kohala.com/start/unp.html">Unix network programming</a> by Richard
Stevens. A classic even though it was written 27 years ago.</li>
</ol>
<h2 id="notes">Notes</h2>
<p>[1] By kernel primitives, I mean C standard library functions that are
interfaces to system calls.<br>
[2] I basically used it in all my previous projects, official or personal.<br>
[3] Fibonacci functions is useful to get a wide range of computational time.
For example, there&rsquo;s a noticeable time difference between calculating
fibonacci of 1 and fibonacci of 32. I got this idea from one of the David
Beazley&rsquo;s <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4">talk</a>.<br>
[4] There are number of gotchas with using synchronization variables in multiple
cores as well. But I will delve into that in some other essay.<br>
[5] Its often said that you cannot turn a sequential program into a
concurrent one without changing program design in a major way. I haven&rsquo;t
faced this problem here.<br>
[6] I am using C here. I have omitted details about memory allocation to focus
on the ideas. I will give a link to the full implementation in the end.<br>
[7] If you using  an object oriented language, you can think of it as a queue
class having a set of public methods and private state variables.<br>
[8] There is another function <code>pthread_cond_broadcast</code> that wakes up all threads
in the waiting list at once. We won&rsquo;t be using it for this problem. But
they are useful in some problems, for example in a Readers-Writers lock
implementation.<br>
[9] I really like <code>kqueue</code> though and I am looking forward to learning and using
it.<br>
[10] <a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a> <br>
[11] I am not able to find specific code in FreeBSD that achieve this. However,
the basic idea is if the lock is uncontested, we don&rsquo;t have to go through
the schedular, don&rsquo;t have to acquire schedular&rsquo;s spinlock and we don&rsquo;t have
to disable interrupts in order to acquire a lock. If the lock is busy
though, we get a scheduling overhead. <br>
[12] They might be pretty old now.</p>
</section>

  
  

  
  
  
  
  <nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  >
    
    <a class="ltr:pr-3 rtl:pl-3" href="https://saurabhjha.github.io/posts/2017-11-07-paper-review-end-to-end-arguments-in-system-design/"
      ><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Review: End-to-end Arguments in System Design</span></a
    >
    
    
    <a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href="https://saurabhjha.github.io/posts/2016-12-13-devops-from-noobs-perspective/"
      ><span>DevOps from a noob&#39;s perspective</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>
  </body>
</html>
