<!doctype html>





































<html
  class="not-ready lg:text-base"
  style="--bg: #f8f5d7"
  lang="en-gb"
  dir="ltr"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Expressing LU factorization using rank one matrices - Saurabh Jha</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="In the last article, we looked at expressing matrix multiplication using rank one matrices. In this article, we will study LU factorization using rank one matrices.
Prerequisites
We are assuming that you are familiar with linear algebra corresponding to a typical undergrad course. In particular, we are assuming that you are familiar with Gaussian elimination and LU factorization.
Running example
In LU factorization, we take a square matrix and turn it into an upper triangular matrix. As our running example, we will look at the following matrix. Let&rsquo;s turn it into an upper triangular matrix using a sequence of row operations." />
  <meta name="author" content="Saurabh Jha" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="/main.min.css" />

  <link rel="stylesheet" as="style" href="/css/index.css">

  
  
  
  
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/theme.svg" />

  
  
  
  
  

  
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/github.svg" />
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/linkedin.svg" />
  
  

  
  
  <script
    defer
    src="https://saurabhjha.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  
  
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
  integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
  crossorigin="anonymous"
/>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
  integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
  crossorigin="anonymous"
></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
  integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
  crossorigin="anonymous"
></script>


<script>
  document.addEventListener('DOMContentLoaded', () =>
    renderMathInElement(document.body, {
      
      
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
      ],
      
      throwOnError: false,
    }),
  );
</script>

  
  
  

  
  <link
    rel="icon"
    href="https://saurabhjha.github.io/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="https://saurabhjha.github.io/apple-touch-icon.png"
  />

  
  <meta name="generator" content="Hugo 0.140.0">

  
  
  
  
  
  
  <meta itemprop="name" content="Expressing LU factorization using rank one matrices">
  <meta itemprop="description" content="In the last article, we looked at expressing matrix multiplication using rank one matrices. In this article, we will study LU factorization using rank one matrices.
Prerequisites We are assuming that you are familiar with linear algebra corresponding to a typical undergrad course. In particular, we are assuming that you are familiar with Gaussian elimination and LU factorization.
Running example In LU factorization, we take a square matrix and turn it into an upper triangular matrix. As our running example, we will look at the following matrix. Let’s turn it into an upper triangular matrix using a sequence of row operations.">
  <meta itemprop="datePublished" content="2022-05-02T00:00:00+00:00">
  <meta itemprop="dateModified" content="2022-05-02T00:00:00+00:00">
  <meta itemprop="wordCount" content="3537">
  
  <meta property="og:url" content="https://saurabhjha.github.io/posts/2022-05-02-lu-rank-one/">
  <meta property="og:site_name" content="Saurabh Jha">
  <meta property="og:title" content="Expressing LU factorization using rank one matrices">
  <meta property="og:description" content="In the last article, we looked at expressing matrix multiplication using rank one matrices. In this article, we will study LU factorization using rank one matrices.
Prerequisites We are assuming that you are familiar with linear algebra corresponding to a typical undergrad course. In particular, we are assuming that you are familiar with Gaussian elimination and LU factorization.
Running example In LU factorization, we take a square matrix and turn it into an upper triangular matrix. As our running example, we will look at the following matrix. Let’s turn it into an upper triangular matrix using a sequence of row operations.">
  <meta property="og:locale" content="en_gb">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-05-02T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-05-02T00:00:00+00:00">

  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Expressing LU factorization using rank one matrices">
  <meta name="twitter:description" content="In the last article, we looked at expressing matrix multiplication using rank one matrices. In this article, we will study LU factorization using rank one matrices.
Prerequisites We are assuming that you are familiar with linear algebra corresponding to a typical undergrad course. In particular, we are assuming that you are familiar with Gaussian elimination and LU factorization.
Running example In LU factorization, we take a square matrix and turn it into an upper triangular matrix. As our running example, we will look at the following matrix. Let’s turn it into an upper triangular matrix using a sequence of row operations.">

  
  

  
  <link rel="canonical" href="https://saurabhjha.github.io/posts/2022-05-02-lu-rank-one/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center">
  <div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center">
    <a class="-translate-y-[1px] text-2xl font-medium" href="https://saurabhjha.github.io/"
      >Saurabh Jha</a
    >
    <div
      class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#f8f5d7'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 rtl:space-x-reverse dark:invert ltr:lg:ml-14 rtl:lg:mr-14 lg:mt-0 lg:items-center"
    >
      
      <a
        class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/saurabhjha"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./linkedin.svg)"
        href="https://linkedin.com/in/saurabh-jha-51706349"
        target="_blank"
        rel="me"
      >
        linkedin
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100vh-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"
    >
      

<article>
  <header class="mb-14">
    <h1 class="!my-0 pb-2.5">Expressing LU factorization using rank one matrices</h1>

    
    <div class="text-xs antialiased opacity-60">
      
      <time>May 2, 2022</time>
      
      
      
      
    </div>
    
  </header>

  <section><p>In the <a href="/posts/2022-01-03-matrix-multiplication-rank-one/">last article</a>, we looked at expressing matrix multiplication using rank one matrices. In this article, we will study LU factorization using rank one matrices.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>We are assuming that you are familiar with linear algebra corresponding to a typical undergrad course. In particular, we are assuming that you are familiar with Gaussian elimination and LU factorization.</p>
<h2 id="running-example">Running example</h2>
<p>In LU factorization, we take a square matrix and turn it into an upper triangular matrix. As our running example, we will look at the following matrix. Let&rsquo;s turn it into an upper triangular matrix using a sequence of row operations.</p>
<div>
  $$
  \begin{align*}
    A = \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      3 & -3 & -2 & 4 \\
      2 & 0 & 2 & 0
    \end{bmatrix}.
  \end{align*}
  $$
</div>
<p>The sequence of row operations along with the intermediate matrices are as follows.</p>
<div>
  $$
  \begin{align*}
    &\begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      3 & -3 & -2 & 4 \\
      2 & 0 & 2 & 0
    \end{bmatrix} \\ \\
    \overset{row2 = row2 + 0.row1}{\longrightarrow}
    &\begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      3 & -3 & -2 & 4 \\
      2 & 0 & 2 & 0
    \end{bmatrix} \\ \\
    \overset{row3 = row3 + (-3).row1}{\longrightarrow}
    &\begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      2 & 0 & 2 & 0
    \end{bmatrix} \\ \\
    \overset{row4 = row4 + (-2).row1}{\longrightarrow}
    &\begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 2 & 4 & -2
    \end{bmatrix} \\ \\
    \overset{row3 = row3 + 0.row2}{\longrightarrow}
    &\begin{bmatrix}
      1 & -1 & -1 & 0 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 2 & 4 & -2
    \end{bmatrix} \\ \\
    \overset{row4 = row4 + 2.row2}{\longrightarrow}
    &\begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 2 & -2
    \end{bmatrix} \\ \\
    \overset{row4 = row4 + (-2).row3}{\longrightarrow}
    &\begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 0 & -4
    \end{bmatrix}.
  \end{align*}
  $$
</div>
<p>We reduced a square matrix into an upper triangular matrix:</p>
<div>
  $$
  \begin{align*}
    \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      3 & -3 & -2 & 4 \\
      2 & 0 & 2 & 0
    \end{bmatrix}
    \rightarrow
    \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 0 & -4
    \end{bmatrix}
  \end{align*}
  $$
</div>
or
<div>
  $$
    A \rightarrow U.
  $$
</div>
<p>We can express the above sequence of operations using the following matrix multiplication:</p>
<div>
  $$
  \begin{align*}
    \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      3 & -3 & -2 & 4 \\
      2 & 0 & 2 & 0
    \end{bmatrix}
    =
    \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & 1 & 0 & 0 \\
      3 & 0 & 1 & 0 \\
      2 & -2 & 2 & 1
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 0 & -4
    \end{bmatrix}
  \end{align*}
  $$
  <p>or</p>
  $$
  \begin{align*}
    A = LU.
  \end{align*}
  $$
</div>
<p>That was LU factorization using row operations. We will now look at an alternative way that uses rank one matrices.</p>
<h2 id="computing-rank-one-components">Computing rank one components</h2>
<p>When we say that we want to express LU factorization using rank one matrices, we are saying that we want to achieve</p>
<div>
  $$
  \begin{align*}
    A = LU = \sum_{k=1}^{n} l_ku_k,
  \end{align*}
  $$
</div>
<div>
  <p>
    where each summation term, $l_ku_k$, is of rank one.
  </p>
  <p>
   Our strategy is going to be to succesively extract rank one components from a matrix and reduce it's rank on each extraction till we are left with a rank zero matrix. For example, if we denote a rank n matrix by $A_{n}$, where the subscript denotes the matrix rank, it would look like this.
  </p>
  $$
  \begin{align*}
    & \space A_{n} \\
    = & \space l_1u_1 + A_{n - 1} \\
    = & \space l_1u_1 + l_2u_2 + A_{n - 2} \\
    & \space ... \\
    = & \space \sum_{k=1}^{n} l_ku_k.
  \end{align*}
  $$
</div>
<p>To achieve this, we will look at the row operations that we did above and reorganize them so that they extract rank one components. The row operations in the above example are these.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row2 <span style="color:#f92672">=</span> row2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.</span>row1
</span></span><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>)<span style="color:#f92672">.</span>row1
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>row1
</span></span><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.</span>row2
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2.</span>row2
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>row3
</span></span></code></pre></div><p>In each of these operations, we use a pivot row to manipulate the rows below the pivot rows. For example, in the first three instructions, the pivot row is <code>row1</code>, in the next two instructions, the pivot row is <code>row2</code> and in the last instruction, the pivot row is <code>row3</code>.</p>
<p>We can group these instructions by the pivot row involved. That is, we can group them by the second operand of addition. This results in the following groups.</p>
<p>Group1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row2 <span style="color:#f92672">=</span> row2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.</span>row1
</span></span><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>)<span style="color:#f92672">.</span>row1
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>row1
</span></span></code></pre></div><p>Group2:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.</span>row2
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2.</span>row2
</span></span></code></pre></div><p>Group3:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>row3
</span></span></code></pre></div><p>As we will see, each of these groups is going to lead to the extraction of a rank one component. Our other requirement was to reduce the rank of the matrix by one on each rank one extraction. To achieve that, we turn the pivot row into zero. This results in the following four groups.</p>
<p>Group1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row1 <span style="color:#f92672">=</span> row1 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>row1
</span></span><span style="display:flex;"><span>row2 <span style="color:#f92672">=</span> row2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.</span>row1
</span></span><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>)<span style="color:#f92672">.</span>row1
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>row1
</span></span></code></pre></div><p>Group2:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row2 <span style="color:#f92672">=</span> row2 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>row2
</span></span><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.</span>row2
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2.</span>row2
</span></span></code></pre></div><p>Group3:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>row3
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>row3
</span></span></code></pre></div><p>Group4:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>row4
</span></span></code></pre></div><p>Let&rsquo;s apply these operations to our example matrix group by group. After applying group1, the result is</p>
<div>
  $$
  \begin{align*}
    \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      3 & -3 & -2 & 4 \\
      2 & 0 & 2 & 0
    \end{bmatrix}
    \overset{group1}\longrightarrow
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 2 & 4 & -2
    \end{bmatrix}.
  \end{align*}
  $$
</div>
<div>
  <p>
    Let's denote the matrix on the right hand side of the arrow by $A_{group1}$, where $A_{group1}$ stands for "$A$ after group1".
  </p>
</div>
<div>
  $$
  \begin{align*}
    A \longrightarrow A_{group1}.
  \end{align*}
  $$
</div>
<div>
  <p>
    We can express the above transformation using the following matrix addition,
  </p>
  $$
  \begin{align*}
    & A = A_{group1} + O_{group1} \\
    \implies & O_{group1} = A - A_{group1},
  \end{align*}
  $$
  <p>
    where $O_{group1}$ stands for "operations of group1".
  </p>
</div>
<div>
  <p>Calculating $O_{group1}$ using $A$ and $A_{group1}$, we have</p>
  $$
  \begin{align*}
    O_{group1} = 
    & \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & 0 & 0 & 0 \\
      3 & -3 & -3 & 3 \\
      2 & -2 & -2 & 2
      \end{bmatrix}.
  \end{align*}
  $$
</div>
<div>
  <p>
    Notice that $O_{group1}$ is a rank one matrix. All of its rows are multiples of the first row. We can therefore express $O_{group1}$ in rank one form.
  </p>
  $$
  \begin{align*}
    O_{group1} = l_1u_1 =
    \begin{bmatrix}
      1 \\
      0 \\
      3 \\
      2
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix}.
  \end{align*}
  $$
</div>
<div>
  We can thus write $A = A_{group1} + O_{group1}$ as
  $$
  \begin{align*}
    A = l_1u_1 + A_{group1}.
  \end{align*}
  $$
</div>
<p>Now let&rsquo;s apply group2 operations which we repeat below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row2 <span style="color:#f92672">=</span> row2 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>row2
</span></span><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.</span>row2
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2.</span>row2
</span></span></code></pre></div><div>
  <p>
    We will apply group2 operations to $A_{group1}$. Doing that results in
  </p>
</div>
<div>
  $$
  \begin{align*}
    & \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 2 & 4 & -2
    \end{bmatrix}
    \overset{group2}\longrightarrow
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 2 & -2
    \end{bmatrix} \\
    \implies
    & A_{group1} \rightarrow A_{group2} \\
    \implies
    & A_{group1} = A_{group2} + O_{group2} \\
    \implies
    & O_{group2} = A_{group1} - A_{group2}.
  \end{align*}  
  $$
  <p>
    Evaluating $O_{group2}$, we have
  </p>
  $$
  \begin{align*}  
    & O_{group2} =
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 2 & 2 & 0
    \end{bmatrix} \\
    & O_{group2} = l_2u_2 =
    \begin{bmatrix}
      0 \\
      1 \\
      0 \\
      -2
    \end{bmatrix}
    \begin{bmatrix}
      0 & -1 & -1 & 0
    \end{bmatrix}.
  \end{align*}
  $$
  <p>
    Earlier, we determined that $A = l_1u_1 + A_{group1}$. Substituting $A_{group1} = l_2u_2 + A_{group2}$, we have
  </p>
  $$
  \begin{align*}
    & A = l_1u_1 + l_2u_2 + A_{group2}.
  \end{align*}
  $$
  <p>
    Let's now apply group3 operations to $A_{group2}$. The group3 operations are these.
  </p>
</div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row3 <span style="color:#f92672">=</span> row3 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>row3
</span></span><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>row3
</span></span></code></pre></div><p>This results in</p>
<div>
  $$
  \begin{align*}
    & \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 2 & -2
    \end{bmatrix}
    \overset{group3}\longrightarrow
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & -4
    \end{bmatrix} \\
    \implies
    & A_{group2} = O_{group3} + A_{group3} \\
    \implies
    & O_{group2} = A_{group2} - A_{group3} \\
    \implies
    & O_{group3} =
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 2 & 2
    \end{bmatrix} \\
    \implies
    & O_{group3} = l_3u_3 =
    \begin{bmatrix}
      0 \\
      0 \\
      1 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      0 & 0 & 1 & 1
    \end{bmatrix}.
  \end{align*}
  $$
</div>
<p>The situation now looks like</p>
<div>
  $$
  \begin{align*}
    A = l_1u_1 + l_2u_2 + l_3u_3 + A_{group3}.
  \end{align*}
  $$
$$
  \begin{align*}
    A_{group3} = \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & -4
    \end{bmatrix}.
  \end{align*}
  $$</div>
<p>The group4 operations is a single operation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>row4 <span style="color:#f92672">=</span> row4 <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>row4
</span></span></code></pre></div><div>
  Applying group4 to $A_{group3}$ results in
  $$
  \begin{align*}
    & \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & -4
    \end{bmatrix}
    \overset{group4}\longrightarrow
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0
    \end{bmatrix} \\
    \implies
    & A_{group3} = O_{group4} + A_{group4} \\
    \implies
    & O_{group4} = A_{group3} - A_{group4} \\
    \implies
    & O_{group4} = \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & -4
    \end{bmatrix} \\
    \implies
    & O_{group4} = l_4u_4 =
    \begin{bmatrix}
      0 \\
      0 \\
      0 \\
      1
    \end{bmatrix}
    \begin{bmatrix}
      0 & 0 & 0 & -4
    \end{bmatrix}.
  \end{align*}
  $$
  <p>
    After applying all four groups, it looks like
  </p>
  $$
  \begin{align*}
    A = l_1u_1 + l_2u_2 + l_3u_3 + l_4u_4 + A_{group4}.
  \end{align*}
  $$
  <p>
    Since $A_{group4}$ is a zero matrix, we have
  </p>
  $$
  \begin{align*}
    A = l_1u_1 + l_2u_2 + l_3u_3 + l_4u_4
  \end{align*}
  $$
  $$
  \begin{align*}
    \implies
    A =
    \begin{bmatrix}
      1 \\
      0 \\
      3 \\
      2
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      1 \\
      0 \\
      -2
    \end{bmatrix}
    \begin{bmatrix}
      0 & -1 & -1 & 0
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      0 \\
      1 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      0 & 0 & 1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      0 \\
      0 \\
      1
    \end{bmatrix}
    \begin{bmatrix}
      0 & 0 & 0 & -4
    \end{bmatrix}.
  \end{align*}
  $$
  <p>Using rank one multiplication, we have the answer</p>
  $$
  \begin{align*}
    A =
    \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & 1 & 0 & 0 \\
      3 & 0 & 1 & 0 \\
      2 & -2 & 2 & 1
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 0 & -4
    \end{bmatrix}.
  \end{align*}
  $$
</div>
<h2 id="algorithm">Algorithm</h2>
<div>
  <p>
    In our above discussion, we reused the existing row operations to extract rank one components. Let's try to come up with the $l_ku_k$ components in a different way.
  </p>
  <p>
    What happens when we extract $l_1u_1$ from our matrix $A$? The original matrix was
  </p>
  $$
  \begin{align*}
    A = \begin{bmatrix}
      1 & -1 & -1 & 1 \\
      0 & -1 & -1 & 0 \\
      3 & -3 & -2 & 4 \\
      2 & 0 & 2 & 0
    \end{bmatrix}.
  \end{align*}
  $$
  <p>
    After subtracting $l_1u_1$ from A, we need zeroes on the pivot row and on the pivot column. In LU factorization, this is done using the pivot row, which is currently the first row of A. What we want is
  </p>
  $$
  \begin{align*}
    A =
    \begin{bmatrix}
      a \\
      b \\
      c \\
      d
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 2 & 4 & -2
    \end{bmatrix},
  \end{align*}
  $$
  <p>
    that is, we need the right multipliers $a$, $b$, $c$, and $d$. We can get these numbers by dividing the first column entries by the pivot. So that looks like
  </p>
  $$
  \begin{align*}
    A & =
    \begin{bmatrix}
      1 / 1 \\
      0 / 1 \\
      3 / 1 \\
      2 / 1
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 2 & 4 & -2
    \end{bmatrix} \\ \\
    & =
    \begin{bmatrix}
      1 \\
      0 \\
      3 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & -1 & -1 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 2 & 4 & -2
    \end{bmatrix}.
  \end{align*}
  $$
  <p>
    The first term here is $l_1u_1$. We now need to extract a rank one component from the second matrix such that its second row and its second row column is zero. We use the second pivot row to do it. It looks like
  </p>
  $$
  \begin{align*}
     A & =
    \begin{bmatrix}
      1 \\
      0 \\
      3 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      a \\
      b \\
      c \\
      d
    \end{bmatrix}
    \begin{bmatrix}
      0 & -1 & -1 & 0
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 2 & -2
    \end{bmatrix}.
  \end{align*}
  $$
  <p>
    The second pivot is -1 so dividing entries in second column by -1 gives us $a$, $b$, $c$, and $d$.
  </p>
  $$
  \begin{align*}
     A & =
    \begin{bmatrix}
      1 \\
      0 \\
      3 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 / -1 \\
      -1 / -1 \\
      0 / -1 \\
      2 / -1
    \end{bmatrix}
    \begin{bmatrix}
      0 & -1 & -1 & 0
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 2 & -2
    \end{bmatrix} \\ \\
    & =
    \begin{bmatrix}
      1 \\
      0 \\
      3 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      1 \\
      0 \\
      -2 \\
    \end{bmatrix}
    \begin{bmatrix}
      0 & -1 & -1 & 0
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 2 & -2
    \end{bmatrix}
  \end{align*}
  $$
  <p>
    We now need to extract a rank one component from the third matrix. The third pivot is 1 so we can write
  </p>
  $$
  \begin{align*}
    A & =
    \begin{bmatrix}
      1 \\
      0 \\
      3 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      1 \\
      0 \\
      -2 \\
    \end{bmatrix}
    \begin{bmatrix}
      0 & -1 & -1 & 0
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      0 \\
      1 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      0 & 0 & 1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 \\
      0 & 0 & 0 & -4
    \end{bmatrix}.
  \end{align*}
  $$
  <p>
    Finally, we need to extract a rank one component from the fourth matrix. The pivot is -4 and it looks like. We omit the remaining zero matrix.
  </p>
  $$
  \begin{align*}
    A = 
    \begin{bmatrix}
      1 \\
      0 \\
      3 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      1 & -1 & -1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      1 \\
      0 \\
      -2 \\
    \end{bmatrix}
    \begin{bmatrix}
      0 & -1 & -1 & 0
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      0 \\
      1 \\
      2 \\
    \end{bmatrix}
    \begin{bmatrix}
      0 & 0 & 1 & 1
    \end{bmatrix} +
    \begin{bmatrix}
      0 \\
      0 \\
      0 \\
      1
    \end{bmatrix}
    \begin{bmatrix}
      0 & 0 & 0 & -4
    \end{bmatrix}.
  \end{align*}
  $$
</div>
<p>The above procedure can be described recursively as follows:</p>
<ol>
<li>Base case: The matrix is zero rank.</li>
<li>Recursive case: Extract a rank one component and reduce the rank of the matrix by one.</li>
</ol>
<div>
  <p>
    The $u_k$ factor of the rank one component is the current pivot row. We compute the $l_k$ factor by dividing all elements of the pivot column by the pivot.
  </p>
</div>
<h2 id="implementation">Implementation</h2>
<p>A python implementation of the above ideas is this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> copy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, body):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>body <span style="color:#f92672">=</span> body
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_number_of_rows</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> len(self<span style="color:#f92672">.</span>body)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_number_of_columns</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> len(self<span style="color:#f92672">.</span>body[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_element</span>(self, row_idx, col_idx):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>body[row_idx][col_idx]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_row</span>(self, row_idx):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Matrix([self<span style="color:#f92672">.</span>body[row_idx]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_column</span>(self, col_idx):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Matrix([[row[col_idx]] <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>body])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __add__(self, other_matrix):
</span></span><span style="display:flex;"><span>        new_matrix <span style="color:#f92672">=</span> copy<span style="color:#f92672">.</span>deepcopy(self)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> row_idx, (row1, row2) <span style="color:#f92672">in</span> enumerate(zip(self<span style="color:#f92672">.</span>body, other_matrix<span style="color:#f92672">.</span>body)):
</span></span><span style="display:flex;"><span>            new_matrix<span style="color:#f92672">.</span>body[row_idx] <span style="color:#f92672">=</span> [num1 <span style="color:#f92672">+</span> num2 <span style="color:#66d9ef">for</span> num1, num2 <span style="color:#f92672">in</span> zip(row1, row2)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> new_matrix
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __mul__(self, other_object):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> isinstance(other_object, int) <span style="color:#f92672">or</span> isinstance(other_object, float):
</span></span><span style="display:flex;"><span>            new_matrix <span style="color:#f92672">=</span> copy<span style="color:#f92672">.</span>deepcopy(self)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> row_idx, row <span style="color:#f92672">in</span> enumerate(self<span style="color:#f92672">.</span>body):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> col_idx, element <span style="color:#f92672">in</span> enumerate(row):
</span></span><span style="display:flex;"><span>                    new_matrix<span style="color:#f92672">.</span>body[row_idx][col_idx] <span style="color:#f92672">=</span> other_object <span style="color:#f92672">*</span> element
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            new_matrix <span style="color:#f92672">=</span> Matrix([[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(other_object<span style="color:#f92672">.</span>body[<span style="color:#ae81ff">0</span>]) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(len(self<span style="color:#f92672">.</span>body))])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> row_idx <span style="color:#f92672">in</span> range(len(self<span style="color:#f92672">.</span>body)):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> col_idx <span style="color:#f92672">in</span> range(len(other_object<span style="color:#f92672">.</span>body[<span style="color:#ae81ff">0</span>])):
</span></span><span style="display:flex;"><span>                    row1_list <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>body[row_idx]
</span></span><span style="display:flex;"><span>                    col2_list <span style="color:#f92672">=</span> [row[col_idx] <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> other_object<span style="color:#f92672">.</span>body]
</span></span><span style="display:flex;"><span>                    new_matrix<span style="color:#f92672">.</span>body[row_idx][col_idx] <span style="color:#f92672">=</span> sum([num1 <span style="color:#f92672">*</span> num2 <span style="color:#66d9ef">for</span> num1, num2 <span style="color:#f92672">in</span> zip(row1_list, col2_list)])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> new_matrix
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __sub__(self, other_matrix):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self <span style="color:#f92672">+</span> (other_matrix <span style="color:#f92672">*</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __truediv__(self, scalar):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> isinstance(scalar, int) <span style="color:#f92672">or</span>  isinstance(scalar, float):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> self <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> scalar)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#34;Cannot divide a matrix by anything other than an int or a float&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __repr__(self):
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>body:
</span></span><span style="display:flex;"><span>            row_string_list <span style="color:#f92672">=</span> [str(element) <span style="color:#66d9ef">if</span> element <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34; </span><span style="color:#e6db74">{</span>element<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> <span style="color:#66d9ef">for</span> element <span style="color:#f92672">in</span> row]
</span></span><span style="display:flex;"><span>            result<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">.</span>join(row_string_list))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>join(result)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lu</span>(matrix, current_pivot_idx<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> current_pivot_idx <span style="color:#f92672">==</span> matrix<span style="color:#f92672">.</span>get_number_of_rows():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pivot <span style="color:#f92672">=</span> matrix<span style="color:#f92672">.</span>get_element(current_pivot_idx, current_pivot_idx)
</span></span><span style="display:flex;"><span>    current_u <span style="color:#f92672">=</span> matrix<span style="color:#f92672">.</span>get_row(current_pivot_idx)
</span></span><span style="display:flex;"><span>    current_l <span style="color:#f92672">=</span> matrix<span style="color:#f92672">.</span>get_column(current_pivot_idx) <span style="color:#f92672">/</span> pivot
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> [(current_l, current_u)]
</span></span><span style="display:flex;"><span>    remaining_matrix <span style="color:#f92672">=</span> matrix <span style="color:#f92672">-</span> current_l <span style="color:#f92672">*</span> current_u
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span>extend(lu(remaining_matrix, current_pivot_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>The original idea behind expressing factorization using the rank one approach was to automatically infer parallelization oppurtunities. Indeed, in our recursive algorithm, each recursive step has some
potential parallelization.</p>
<p>What actually ended up happening was viewing factorization using the rank one approach helped in algorithm design. The recursive structure of LU decomposition was more prominent for me in this framework.</p>
<p>It is worthwhile to go further in this direction. I am not sure where will it go and whether it will lead to anything. My strategy is not to go broad in the sense of covering other factorizations like QR or SVD but instead to go deep and implement this with all the automatic parallelization possible.</p>
<p>One thing I am unhappy about is the algorithm is too detailed about where the data is coming from and going to. We need a higher level language or notation to express data dependencies that can be somehow be compiled down to actual operations. Maybe I will explore this in a future article.</p>
</section>

  
  

  
  
  
  
  <nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  >
    
    
    <a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href="https://saurabhjha.github.io/posts/2022-01-03-matrix-multiplication-rank-one/"
      ><span>Expressing matrix multiplications using rank one matrices</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>
  </body>
</html>
