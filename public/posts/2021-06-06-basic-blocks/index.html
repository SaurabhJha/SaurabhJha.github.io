<!doctype html>





































<html
  class="not-ready lg:text-base"
  style="--bg: #f8f5d7"
  lang="en-gb"
  dir="ltr"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Constructing basic blocks - Saurabh Jha</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="In this article, we cover concepts from the second lesson of the advanced compilers course from Cornell. However, the specific algorithms discussed in this article are different from the ones discussed in the course.
Introduction
To execute a program written in a high level-language, we first need to translate it into a processor-specific machine language program. One way to do
this is to first translate the program text into a data structure. We can then use that data structure to generate a machine language program. These
intermediary data structures are called intermediate representations." />
  <meta name="author" content="Saurabh Jha" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="main.min.css" />

  <link rel="stylesheet" as="style" href="/css/index.css">

  
  
  
  
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/theme.svg" />

  
  
  
  
  

  
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/github.svg" />
  
  <link rel="preload" as="image" href="https://saurabhjha.github.io/linkedin.svg" />
  
  

  
  
  <script
    defer
    src="https://saurabhjha.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  
  
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
  integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
  crossorigin="anonymous"
/>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
  integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
  crossorigin="anonymous"
></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
  integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
  crossorigin="anonymous"
></script>


<script>
  document.addEventListener('DOMContentLoaded', () =>
    renderMathInElement(document.body, {
      
      
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
      ],
      
      throwOnError: false,
    }),
  );
</script>

  
  
  

  
  <link
    rel="icon"
    href="https://saurabhjha.github.io/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="https://saurabhjha.github.io/apple-touch-icon.png"
  />

  
  <meta name="generator" content="Hugo 0.140.0">

  
  
  
  
  
  
  <meta itemprop="name" content="Constructing basic blocks">
  <meta itemprop="description" content="In this article, we cover concepts from the second lesson of the advanced compilers course from Cornell. However, the specific algorithms discussed in this article are different from the ones discussed in the course.
Introduction To execute a program written in a high level-language, we first need to translate it into a processor-specific machine language program. One way to do this is to first translate the program text into a data structure. We can then use that data structure to generate a machine language program. These intermediary data structures are called intermediate representations.">
  <meta itemprop="datePublished" content="2021-06-06T00:00:00+00:00">
  <meta itemprop="dateModified" content="2021-06-06T00:00:00+00:00">
  <meta itemprop="wordCount" content="2930">
  
  <meta property="og:url" content="https://saurabhjha.github.io/posts/2021-06-06-basic-blocks/">
  <meta property="og:site_name" content="Saurabh Jha">
  <meta property="og:title" content="Constructing basic blocks">
  <meta property="og:description" content="In this article, we cover concepts from the second lesson of the advanced compilers course from Cornell. However, the specific algorithms discussed in this article are different from the ones discussed in the course.
Introduction To execute a program written in a high level-language, we first need to translate it into a processor-specific machine language program. One way to do this is to first translate the program text into a data structure. We can then use that data structure to generate a machine language program. These intermediary data structures are called intermediate representations.">
  <meta property="og:locale" content="en_gb">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-06-06T00:00:00+00:00">
    <meta property="article:modified_time" content="2021-06-06T00:00:00+00:00">

  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Constructing basic blocks">
  <meta name="twitter:description" content="In this article, we cover concepts from the second lesson of the advanced compilers course from Cornell. However, the specific algorithms discussed in this article are different from the ones discussed in the course.
Introduction To execute a program written in a high level-language, we first need to translate it into a processor-specific machine language program. One way to do this is to first translate the program text into a data structure. We can then use that data structure to generate a machine language program. These intermediary data structures are called intermediate representations.">

  
  

  
  <link rel="canonical" href="https://saurabhjha.github.io/posts/2021-06-06-basic-blocks/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center">
  <div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center">
    <a class="-translate-y-[1px] text-2xl font-medium" href="https://saurabhjha.github.io/"
      >Saurabh Jha</a
    >
    <div
      class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#f8f5d7'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 rtl:space-x-reverse dark:invert ltr:lg:ml-14 rtl:lg:mr-14 lg:mt-0 lg:items-center"
    >
      
      <a
        class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/saurabhjha"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./linkedin.svg)"
        href="https://linkedin.com/in/saurabh-jha-51706349"
        target="_blank"
        rel="me"
      >
        linkedin
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100vh-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"
    >
      

<article>
  <header class="mb-14">
    <h1 class="!my-0 pb-2.5">Constructing basic blocks</h1>

    
    <div class="text-xs antialiased opacity-60">
      
      <time>Jun 6, 2021</time>
      
      
      
      
    </div>
    
  </header>

  <section><p><em>In this article, we cover concepts from the <a href="https://www.cs.cornell.edu/courses/cs6120/2020fa/lesson/2/">second lesson</a> of the <a href="https://www.cs.cornell.edu/courses/cs6120/2020fa/self-guided/">advanced compilers course</a> from Cornell. However, the specific algorithms discussed in this article are different from the ones discussed in the course.</em></p>
<h2 id="introduction">Introduction</h2>
<p>To execute a program written in a high level-language, we first need to translate it into a processor-specific machine language program. One way to do
this is to first translate the program text into a data structure. We can then use that data structure to generate a machine language program. These
intermediary data structures are called intermediate representations.</p>
<p><img src="/img/compilers/basic_blocks/interm_rep_single.png" alt="Intermediate representation single"></p>
<p>These intermediate representation languages are closer to assembly languages than the source languages. They have more primitive operators and more
primitive control flow facilities. The intermediate representations are effectively abstracted assembly languages that do not have various architecture
quirks.</p>
<p>A benefit of this design is that we can translate multiple source languages into an intermediate representation. That intermediate representation can then
generate different processor-specific programs. It is easier to write new languages for existing architectures and for an existing compiler to target new
architectures.</p>
<p><img src="/img/compilers/basic_blocks/interm_rep_multi.png" alt="Intermediate representation multi"></p>
<p>Another benefit of this design is that the analyses and transformations done on intermediate representations remain intact when we generate machine code from
that intermediate representation. It&rsquo;s a consequence of intermediate representations being a good model of the processor specific languages.</p>
<p>Some examples of intermediate representations are <a href="https://llvm.org/docs/LangRef.html">Llvm IR</a> and <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">Java bytecode</a>.</p>
<p>In this article, we will study a method of grouping instructions written in an intermediate language. These instruction groups are called <em>basic blocks</em>.
We will start by describing the relevant parts of the IR language that we will be using. After that, we will represent our program using a data structure
called the <em>control flow graph</em>. And finally, we will use the control flow graph representation to construct basic blocks.</p>
<h2 id="relevant-intermediate-representation-ir-background">Relevant intermediate representation (IR) background</h2>
<p>We will be using <a href="https://capra.cs.cornell.edu/bril/">Bril</a> intermediate representation which came out of the <a href="https://capra.cs.cornell.edu/">Capra</a> group
at <a href="https://www.cornell.edu/">Cornell</a>. We will restrict ourselves to the following features of Bril.</p>
<ol>
<li>Bril programs have a textual representation and a json representation. These representations are interchangeble.</li>
<li>The Bril programs under consideration will have only one function named <code>main</code>.</li>
<li>Labels mark specific points in a program. They are used to refer to instructions by other instructions of a program.</li>
<li>An instruction can be either a label or an operation.</li>
<li>There are two control flow instructions: <code>jmp</code> and <code>br</code>.</li>
<li>The <code>jmp</code> is an unconditional jump that takes one argument, the label to jump to.</li>
<li>The <code>br</code> is a conditional jump that takes three arguments. It takes a variable of type bool and two labels. The program jumps to the first label
if the variable is true and the second label otherwise.</li>
</ol>
<p>More details about bril can be found in the <a href="https://capra.cs.cornell.edu/bril/">documentation</a>.</p>
<p>Here are some examples. Below is a simple program that prints a constant.</p>
<pre tabindex="0"><code>@main {
  v: int = const 4;
  print v;
}
</code></pre><p>Its json representation is this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;functions&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;main&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;instrs&#34;</span>: [
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;print&#34;</span>, <span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;v&#34;</span>]}
</span></span><span style="display:flex;"><span>      ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here&rsquo;s a program that uses the <code>jmp</code> instruction to do an unconditional jump to a label.</p>
<pre tabindex="0"><code>@main {
  v: int = const 4;
  jmp .somewhere;
  v: int = const 2;
.somewhere:
  print v;
}
</code></pre><p>Its json representation is this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;functions&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;main&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;instrs&#34;</span>: [
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;jmp&#34;</span>, <span style="color:#f92672">&#34;labels&#34;</span>: [<span style="color:#e6db74">&#34;somewhere&#34;</span>]},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#e6db74">&#34;somewhere&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;print&#34;</span>, <span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;v&#34;</span>]}
</span></span><span style="display:flex;"><span>      ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And here&rsquo;s a program that uses <code>br</code> to do a conditional jump.</p>
<pre tabindex="0"><code>@main {
  v: int = const 4;
  b: bool = const false;
  br b .there .here;
.here:
  v: int = const 2;
.there:
  print v;
}
</code></pre><p>Here, the value of <code>b</code> determines whether the jump is going to <code>here</code> or <code>there</code>. Since the value of <code>b</code> is hardcoded to <code>false</code> in this example, it will
always jump to the <code>.here</code> label. The json representation looks like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;functions&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;main&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;instrs&#34;</span>: [
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;bool&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#66d9ef">false</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;br&#34;</span>, <span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;b&#34;</span>], <span style="color:#f92672">&#34;labels&#34;</span>: [<span style="color:#e6db74">&#34;there&#34;</span>, <span style="color:#e6db74">&#34;here&#34;</span>]},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#e6db74">&#34;here&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#e6db74">&#34;there&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;print&#34;</span>, <span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;v&#34;</span>]}
</span></span><span style="display:flex;"><span>      ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="control-flow-graph">Control flow graph</h2>
<p>A control flow graph represents the flow of control of a function. Each instruction is a vertex in the graph and the vertices are connected
according to the flow of control of instructions.</p>
<p>For example, for the program</p>
<pre tabindex="0"><code>@main {
  v: int = const 4;
  print v;
}
</code></pre><p>the control flow graph will looks like this.</p>
<p><img src="/img/compilers/basic_blocks/simple_cfg.png" alt="Simple cfg"></p>
<p>For the program</p>
<pre tabindex="0"><code>@main {
  v: int = const 4;
  jmp .somewhere;
  v: int = const 2;
.somewhere:
  print v;
}
</code></pre><p>it will look like this.</p>
<p><img src="/img/compilers/basic_blocks/jmp_cfg.png" alt="Jump cfg"></p>
<p>To construct the control flow graph for a program, we need to compute the instructions that we can directly go to from each instruction. In our intermediate
representation, the answers are as follows.</p>
<ol>
<li>If the instruction is neither a <code>jmp</code> nor a <code>br</code>, the reachable instruction is the next instruction in the instruction array.</li>
<li>If the instruction is a <code>jmp</code>, the next instruction is the instruction identified by the label of the jump.</li>
<li>If the instruction is a <code>br</code>, there are two instructions reachable from that instruction, identified by the labels of the instruction.</li>
</ol>
<p>Points 2. and 3. refer to labels. To construct the control flow graph, we first need to associate labels with their corresponding instructions. Let&rsquo;s clarify
this with an example. Here&rsquo;s the json representation of our <code>jmp</code> program.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;functions&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;main&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;instrs&#34;</span>: [
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;jmp&#34;</span>, <span style="color:#f92672">&#34;labels&#34;</span>: [<span style="color:#e6db74">&#34;somewhere&#34;</span>]},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#e6db74">&#34;somewhere&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;print&#34;</span>, <span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;v&#34;</span>]}
</span></span><span style="display:flex;"><span>      ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In Bril, an instruction is a label if it has the <code>label</code> property. There is only one such instruction in this program, <code>{&quot;label&quot;: &quot;somewhere&quot;}</code>,
which is the second last instruction.</p>
<p>Before constructing the control flow graph, we need to map labels to indices of instructions in the instruction array. Here is a python implementation of this
idea which takes the <code>instrs</code> list from the json representation as input.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">map_labels_to_instructions</span>(instrs):
</span></span><span style="display:flex;"><span>    label_to_instruction <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> idx, instr <span style="color:#f92672">in</span> enumerate(self<span style="color:#f92672">.</span>instrs):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;label&#34;</span> <span style="color:#f92672">in</span> instr:  <span style="color:#75715e"># is the instruction a label?</span>
</span></span><span style="display:flex;"><span>            label_to_instruction[instr[<span style="color:#e6db74">&#34;label&#34;</span>]] <span style="color:#f92672">=</span> idx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> label_to_instruction
</span></span></code></pre></div><p>Let&rsquo;s do an example run of the above program. For the <code>br</code> program reproduced below,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;functions&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;main&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;instrs&#34;</span>: [
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;bool&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#66d9ef">false</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;br&#34;</span>, <span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;b&#34;</span>], <span style="color:#f92672">&#34;labels&#34;</span>: [<span style="color:#e6db74">&#34;there&#34;</span>, <span style="color:#e6db74">&#34;here&#34;</span>]},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#e6db74">&#34;here&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#e6db74">&#34;there&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;print&#34;</span>, <span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;v&#34;</span>]}
</span></span><span style="display:flex;"><span>      ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>the output would be the following dictionary.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;here&#34;</span>: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;there&#34;</span>: <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We are ready to construct the control flow graph of a program. We will represent this graph using adjacency list representation.
For each instruction, we need to figure out the instructions it can go to.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">construct_graph</span>(instrs):
</span></span><span style="display:flex;"><span>    label_to_instruction <span style="color:#f92672">=</span> map_labels_to_instructions(instrs)
</span></span><span style="display:flex;"><span>    graph <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>defaultdict(set)  <span style="color:#75715e"># Adjacency list representation of program</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> idx, instr <span style="color:#f92672">in</span> enumerate(self<span style="color:#f92672">.</span>instrs):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;op&#34;</span> <span style="color:#f92672">in</span> instr <span style="color:#f92672">and</span> instr[<span style="color:#e6db74">&#34;op&#34;</span>] <span style="color:#f92672">in</span> {<span style="color:#e6db74">&#34;jmp&#34;</span>, <span style="color:#e6db74">&#34;br&#34;</span>}:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># It is a jmp or a br. Find destination instruction indexes corresponding to labels and connect</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># them to this instruction index.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> label <span style="color:#f92672">in</span> instr[<span style="color:#e6db74">&#34;labels&#34;</span>]:
</span></span><span style="display:flex;"><span>                dest_instr_idx <span style="color:#f92672">=</span> label_to_instruction[label]
</span></span><span style="display:flex;"><span>                graph[idx]<span style="color:#f92672">.</span>add(dest_instr_idx)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> idx <span style="color:#f92672">&lt;</span> len(self<span style="color:#f92672">.</span>instrs) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Its not the last instruction. Connect it to the subsequent instruction.</span>
</span></span><span style="display:flex;"><span>            graph[idx]<span style="color:#f92672">.</span>add(idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> graph
</span></span></code></pre></div><p>This program is identifying each instruction with its array index. For our above <code>br</code> program, it will construct this dictionary.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>: {<span style="color:#ae81ff">1</span>},
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>: {<span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>: {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>},
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>: {<span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">4</span>: {<span style="color:#ae81ff">5</span>},
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5</span>: {<span style="color:#ae81ff">6</span>},
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Pictorially, it will look like this. We have labelled vertices here with instruction numbers and their corresponding instructions.</p>
<p><img src="/img/compilers/basic_blocks/br_cfg.png" alt="Br cfg"></p>
<h2 id="basic-blocks">Basic blocks</h2>
<p>We now have all the concepts we need to discuss basic blocks. A basic block is a sequence of instructions such that:</p>
<ol>
<li>Executing its first instruction guarantees that all instructions within that block will execute.</li>
<li>We can enter a block via the first instruction only. There is no other entry point for a basic block.</li>
</ol>
<p>Let&rsquo;s construct basic blocks for the following program.</p>
<pre tabindex="0"><code>@main {
  v: int = const 4;
  b: bool = const false;
  br b .there .here;
.here:
  v: int = const 2;
.there:
  print v;
  jmp .here;
}
</code></pre><p>Starting from the first instruction, we can see that if <code>v: int = const 4;</code> executes, then <code>b: bool = const false;</code> will definitely execute. And if
<code>b: bool = const false;</code> executes, then <code>br b .there .here</code> will definitely execute.</p>
<p>It could happen that <code>.here</code> executes after <code>br b .there .here</code>. But <code>.here</code> will also execute after the last instruction <code>jmp .here</code>. According to the
second point of our definition, we can only enter a basic block via its first instruction. Thus, we must finish our current block at <code>br b .there .here</code> and start a new
one at <code>.here</code>.</p>
<p>If <code>.here</code> executes, then <code>v: int = const 2</code> will definitely execute. And while its true that the execution of <code>v: inst = const 2</code> implies the execution
of <code>.there</code>, it is also true that <code>.there</code> could follow <code>br b .there .here</code>. Thus, <code>v: int = const 2</code> should end the current block and <code>.there</code> should
start a new block.</p>
<p>Similarly, the block starting from <code>.there</code> ends at <code>jmp .here</code>.</p>
<p>The below figure shows the control flow graph of the above program with the basic blocks marked by gray boxes.</p>
<p><img src="/img/compilers/basic_blocks/br2_cfg_dotted.png" alt="Br2 dotted cfg"></p>
<p>Let&rsquo;s convert our above intuition into an algorithm and its implementation. Since we are modeling our list of instructions as graphs, we should translate
the requirements of basic blocks into graphical terms. We can re-express the two criteria like this.</p>
<ol>
<li>Each vertex in a block except the last one has one outgoing edge. The last vertex can have either no outgoing edge or multiple outgoing edges.</li>
<li>Each vertex in a block except the first has one incoming edge. The first vertex can have either no incoming edge or multiple incoming edges.</li>
</ol>
<p>We can check the first requirement for each vertex by doing a depth-first search on the graph. To check the second requirement, we need to compute the
parent vertices for each vertex. We can determine the parent vertices for each vertex by doing a breadth-first search on our control flow graph. The
python implementation is as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">construct_child_parent_relationship</span>(graph):
</span></span><span style="display:flex;"><span>    child_to_parent <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>defaultdict(set)  <span style="color:#75715e"># Each vertex can have multiple parents.</span>
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>deque()
</span></span><span style="display:flex;"><span>    unvisited <span style="color:#f92672">=</span> {idx <span style="color:#66d9ef">for</span> idx <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(self<span style="color:#f92672">.</span>instrs))}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">0</span>)  <span style="color:#75715e"># Start from the first vertex.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> queue:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Main BFS loop.</span>
</span></span><span style="display:flex;"><span>        current_vertex <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> next_vertex <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[current_vertex]:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Whether or not we have seen next_vertex before, add current_vertex as its parent.</span>
</span></span><span style="display:flex;"><span>            child_to_parent[next_vertex]<span style="color:#f92672">.</span>add(current_vertex)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> next_vertex <span style="color:#f92672">in</span> unvisited:
</span></span><span style="display:flex;"><span>                unvisited<span style="color:#f92672">.</span>remove(next_vertex)
</span></span><span style="display:flex;"><span>                queue<span style="color:#f92672">.</span>append(next_vertex)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> queue <span style="color:#f92672">and</span> unvisited:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># If the queue is empty but there are still some unvisited vertices, pop a random</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># unvisited vertex into the queue.</span>
</span></span><span style="display:flex;"><span>            queue<span style="color:#f92672">.</span>append(unvisited<span style="color:#f92672">.</span>pop())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> child_to_parent
</span></span></code></pre></div><p>We are now ready to group vertices into basic blocks. We start with the first instruction and keep constructing new basic blocks till we have exhausted all the instructions. We do this using a depth-first search. Because we have several state variables related to basic blocks, it would be easier to do it using an iterative depth-first search. Here is an implementation of our two requirements. Because the code is relatively more involved, we run it on one of our example programs right after the code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">construct_basic_blocks</span>(instrs):
</span></span><span style="display:flex;"><span>    child_to_parent <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>construct_child_parent_relationship()
</span></span><span style="display:flex;"><span>    stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    basic_blocks <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    current_block <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    unvisited <span style="color:#f92672">=</span> {idx <span style="color:#66d9ef">for</span> idx <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(self<span style="color:#f92672">.</span>instrs))}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> stack:
</span></span><span style="display:flex;"><span>        current_vertex <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> current_block <span style="color:#f92672">or</span> len(child_to_parent[current_vertex]) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            current_block<span style="color:#f92672">.</span>append(current_vertex)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            basic_blocks<span style="color:#f92672">.</span>append(current_block)
</span></span><span style="display:flex;"><span>            current_block <span style="color:#f92672">=</span> [current_vertex]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>graph[current_vertex]) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># If the current vertex has either zero children or more than one children, it must terminate</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># the current block and we must start a new block. Multiple edges cannot come out from within</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># a block.</span>
</span></span><span style="display:flex;"><span>            basic_blocks<span style="color:#f92672">.</span>append(current_block)
</span></span><span style="display:flex;"><span>            current_block <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        unvisited_children <span style="color:#f92672">=</span> {vertex <span style="color:#66d9ef">for</span> vertex <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[current_vertex] <span style="color:#66d9ef">if</span> vertex <span style="color:#f92672">in</span> unvisited}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> unvisited_children:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># No child for the current vertex. End current block and start a new block.</span>
</span></span><span style="display:flex;"><span>            basic_blocks<span style="color:#f92672">.</span>append(current_block)
</span></span><span style="display:flex;"><span>            current_block <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Continue dfs on unseen children.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> next_vertex <span style="color:#f92672">in</span> unvisited_children:
</span></span><span style="display:flex;"><span>                unvisited<span style="color:#f92672">.</span>remove(next_vertex)
</span></span><span style="display:flex;"><span>                stack<span style="color:#f92672">.</span>append(next_vertex)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> stack <span style="color:#f92672">and</span> unvisited:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># If the stack is empty but there are some unprocessed vertices, add them to the stack.</span>
</span></span><span style="display:flex;"><span>            stack<span style="color:#f92672">.</span>append(unvisited<span style="color:#f92672">.</span>pop())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    basic_blocks <span style="color:#f92672">=</span> [current_block <span style="color:#66d9ef">for</span> current_block <span style="color:#f92672">in</span> basic_blocks <span style="color:#66d9ef">if</span> current_block]
</span></span><span style="display:flex;"><span>    basic_blocks<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> basic_blocks
</span></span></code></pre></div><p>Let&rsquo;s run this code on the below program. To make it easy to read, we converted the <code>instrs</code> array into an object with indices. It will help in
relating instructions to their indices.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;functions&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;main&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;instrs&#34;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0:</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">1:</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;bool&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#66d9ef">false</span>},
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">:</span> {<span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;br&#34;</span>, <span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;b&#34;</span>], <span style="color:#f92672">&#34;labels&#34;</span>: [<span style="color:#e6db74">&#34;there&#34;</span>, <span style="color:#e6db74">&#34;here&#34;</span>]},
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">3</span><span style="color:#960050;background-color:#1e0010">:</span> {<span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#e6db74">&#34;here&#34;</span>},
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">:</span> {<span style="color:#f92672">&#34;dest&#34;</span>: <span style="color:#e6db74">&#34;v&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#f92672">&#34;value&#34;</span>: <span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">5</span><span style="color:#960050;background-color:#1e0010">:</span> {<span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#e6db74">&#34;there&#34;</span>},
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">6</span><span style="color:#960050;background-color:#1e0010">:</span> {<span style="color:#f92672">&#34;args&#34;</span>: [<span style="color:#e6db74">&#34;v&#34;</span>], <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;print&#34;</span>},
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">7</span><span style="color:#960050;background-color:#1e0010">:</span> {<span style="color:#f92672">&#34;labels&#34;</span>: [<span style="color:#e6db74">&#34;here&#34;</span>], <span style="color:#f92672">&#34;op&#34;</span>: <span style="color:#e6db74">&#34;jmp&#34;</span>}
</span></span><span style="display:flex;"><span>      <span style="color:#960050;background-color:#1e0010">}</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The control flow graph and the child to parent relationships for the above program looks like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>control_flow_graph <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>: {<span style="color:#ae81ff">1</span>}, <span style="color:#ae81ff">1</span>: {<span style="color:#ae81ff">2</span>}, <span style="color:#ae81ff">2</span>: {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>}, <span style="color:#ae81ff">3</span>: {<span style="color:#ae81ff">4</span>}, <span style="color:#ae81ff">4</span>: {<span style="color:#ae81ff">5</span>}, <span style="color:#ae81ff">5</span>: {<span style="color:#ae81ff">6</span>}, <span style="color:#ae81ff">6</span>: {<span style="color:#ae81ff">7</span>}, <span style="color:#ae81ff">7</span>: {<span style="color:#ae81ff">3</span>}}
</span></span><span style="display:flex;"><span>child_parent_dict <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>: {<span style="color:#ae81ff">0</span>}, <span style="color:#ae81ff">2</span>: {<span style="color:#ae81ff">1</span>}, <span style="color:#ae81ff">3</span>: {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span>}, <span style="color:#ae81ff">5</span>: {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>}, <span style="color:#ae81ff">4</span>: {<span style="color:#ae81ff">3</span>}, <span style="color:#ae81ff">6</span>: {<span style="color:#ae81ff">5</span>}, <span style="color:#ae81ff">7</span>: {<span style="color:#ae81ff">6</span>}}
</span></span></code></pre></div><p>We are now ready to simulate our <code>construct_basic_blocks</code> function. Here are the four variables that we will track along with their initial values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>}
</span></span></code></pre></div><p>We enter the <code>while</code> loop of line 7 for the first time. Because the <code>current_block</code> is empty, the <code>if</code> block of line 9 will execute. Since there is only
one child of <code>1</code>, the <code>if</code> block of line 15 won&rsquo;t execute. And since there is an unvisited child of vertex <code>0</code>, the <code>else</code> block of line 27 will execute.
The <code>if</code> block of line 33 will not execute. The situation looks like this now.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>}
</span></span></code></pre></div><p>Entering the <code>while</code> loop again, the <code>if</code> block on line 9 will execute because <code>1</code> has only one parent. And since <code>1</code> has one unvisited child,
the <code>if</code> block of line 15 won&rsquo;t execute and the <code>else</code> block of line 27 will execute. The <code>if</code> block of line 33 will again be skipped. After second
iteration, the variables look like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>}
</span></span></code></pre></div><p>The next iteration of the <code>while</code> loop will be different. The current vertex <code>2</code> has just one parent so it will be added
to the current block. But vertex <code>2</code> has two children so we will end the current block in the <code>if</code> block of line 15 and start a new block. Since the children
of <code>2</code> are in <code>unvisited</code>, we add them to the stack in the <code>else</code> block of line 27.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>]]
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>}
</span></span></code></pre></div><p>Now <code>5</code> will be our current vertex. Because <code>5</code> has two parents, <code>2</code> and <code>4</code>, the current block ends and a new block is initalised with <code>5</code> in the <code>else</code> block of line 11. Since <code>5</code> has an unvisited child, the <code>else</code> block of line 27 will execute. The <code>if</code> block of line 33 will not execute.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>]]
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>}
</span></span></code></pre></div><p>Now the current vertex is <code>6</code> which has one parent and one unvisited child so the state variables look like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>]]
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>]
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {<span style="color:#ae81ff">4</span>}
</span></span></code></pre></div><p>The current vertex is <code>7</code> which has one parent but has no unvisited child. We therefore end the current block and start a new one. The variables
look like this now.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>]]
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {<span style="color:#ae81ff">4</span>}
</span></span></code></pre></div><p>The current block is empty so we initialise a new block in the <code>if</code> of line 9 with <code>3</code>. <code>3</code> has one unvisited children which we add to the stack.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>]]
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {}
</span></span></code></pre></div><p>Now, the vertex <code>4</code> has just one parent and no unvisited child. The stack would be empty now and there are no unvisited vertices left.
<code>4</code> will be added to the current block in the <code>if</code> block of line 9. There are no unvisited vertices left so the current block will be appended to
the list of basic blocks in the <code>if</code> block of line 23. There will no more iterations of the while loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]]
</span></span><span style="display:flex;"><span>current_block <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>stack <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>unvisited <span style="color:#f92672">=</span> {}
</span></span></code></pre></div><p>After the loop, we remove empty blocks and sort basic blocks. Sorting helps in recombining basic blocks to form a complete list of instructions. The final
result will look like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>basic_blocks <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>], [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>]]
</span></span></code></pre></div><p>The basic blocks we computed using this function match the ones we computed intutively using graph above.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Breaking a list of instructions into basic blocks is the first step towards compiler optimizations. In a next article, we will discuss optimizations
that we can do within a basic block.</p>
</section>

  
  

  
  
  
  
  <nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  >
    
    <a class="ltr:pr-3 rtl:pl-3" href="https://saurabhjha.github.io/posts/2022-01-03-matrix-multiplication-rank-one/"
      ><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Expressing matrix multiplications using rank one matrices</span></a
    >
    
    
    <a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href="https://saurabhjha.github.io/posts/2020-07-21-implementing-parser-generators/"
      ><span>Implementing parsers</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>
  </body>
</html>
