<!doctype html>





































<html
  class="not-ready lg:text-base"
  style="--bg: #f8f5d7"
  lang="en-gb"
  dir="ltr"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Implementing parsers - Saurabh Jha</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="Introduction
Once we have tokenized some program text, we need to check whether the tokens are in the correct sequence. For example, which of the following token
sequences are valid?

Tokenization of &ldquo;32 &#43; 4&rdquo;: &ldquo;&lt;number, 32&gt;, &lt;&#43;, &#43;&gt;, &lt;number, 4&gt;&rdquo;.
Tokenization of &ldquo;&#43; 32 4&rdquo;: &ldquo;&lt;&#43;, &#43;&gt;, &lt;number, 32&gt;, &lt;number, 4&gt;&rdquo;.

Regular expressions are not powerful enough to make the choices like these.  The rules about which token sequences are valid constitute the
syntax of a programming language. In this article, we will develop the concepts and techniques of checking syntactic correctness of a program
text." />
  <meta name="author" content="Saurabh Jha" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="http://saurabhjha.github.io/main.min.css" />

  <link rel="stylesheet" as="style" href="/css/index.css">

  
  
  
  
  
  <link rel="preload" as="image" href="http://saurabhjha.github.io/theme.svg" />

  
  
  
  
  

  
  
  <link rel="preload" as="image" href="http://saurabhjha.github.io/github.svg" />
  
  <link rel="preload" as="image" href="http://saurabhjha.github.io/linkedin.svg" />
  
  

  
  
  <script
    defer
    src="http://saurabhjha.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  
  
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
  integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
  crossorigin="anonymous"
/>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
  integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
  crossorigin="anonymous"
></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
  integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
  crossorigin="anonymous"
></script>


<script>
  document.addEventListener('DOMContentLoaded', () =>
    renderMathInElement(document.body, {
      
      
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
      ],
      
      throwOnError: false,
    }),
  );
</script>

  
  
  

  
  <link
    rel="icon"
    href="http://saurabhjha.github.io/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="http://saurabhjha.github.io/apple-touch-icon.png"
  />

  
  <meta name="generator" content="Hugo 0.140.0">

  
  
  
  
  
  
  <meta itemprop="name" content="Implementing parsers">
  <meta itemprop="description" content="Introduction Once we have tokenized some program text, we need to check whether the tokens are in the correct sequence. For example, which of the following token sequences are valid?
Tokenization of “32 &#43; 4”: “&lt;number, 32&gt;, &lt;&#43;, &#43;&gt;, &lt;number, 4&gt;”. Tokenization of “&#43; 32 4”: “&lt;&#43;, &#43;&gt;, &lt;number, 32&gt;, &lt;number, 4&gt;”. Regular expressions are not powerful enough to make the choices like these. The rules about which token sequences are valid constitute the syntax of a programming language. In this article, we will develop the concepts and techniques of checking syntactic correctness of a program text.">
  <meta itemprop="datePublished" content="2020-07-21T00:00:00+00:00">
  <meta itemprop="dateModified" content="2020-07-21T00:00:00+00:00">
  <meta itemprop="wordCount" content="8533">
  
  <meta property="og:url" content="http://saurabhjha.github.io/posts/2020-07-21-implementing-parser-generators/">
  <meta property="og:site_name" content="Saurabh Jha">
  <meta property="og:title" content="Implementing parsers">
  <meta property="og:description" content="Introduction Once we have tokenized some program text, we need to check whether the tokens are in the correct sequence. For example, which of the following token sequences are valid?
Tokenization of “32 &#43; 4”: “&lt;number, 32&gt;, &lt;&#43;, &#43;&gt;, &lt;number, 4&gt;”. Tokenization of “&#43; 32 4”: “&lt;&#43;, &#43;&gt;, &lt;number, 32&gt;, &lt;number, 4&gt;”. Regular expressions are not powerful enough to make the choices like these. The rules about which token sequences are valid constitute the syntax of a programming language. In this article, we will develop the concepts and techniques of checking syntactic correctness of a program text.">
  <meta property="og:locale" content="en_gb">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-07-21T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-07-21T00:00:00+00:00">

  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Implementing parsers">
  <meta name="twitter:description" content="Introduction Once we have tokenized some program text, we need to check whether the tokens are in the correct sequence. For example, which of the following token sequences are valid?
Tokenization of “32 &#43; 4”: “&lt;number, 32&gt;, &lt;&#43;, &#43;&gt;, &lt;number, 4&gt;”. Tokenization of “&#43; 32 4”: “&lt;&#43;, &#43;&gt;, &lt;number, 32&gt;, &lt;number, 4&gt;”. Regular expressions are not powerful enough to make the choices like these. The rules about which token sequences are valid constitute the syntax of a programming language. In this article, we will develop the concepts and techniques of checking syntactic correctness of a program text.">

  
  

  
  <link rel="canonical" href="http://saurabhjha.github.io/posts/2020-07-21-implementing-parser-generators/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center">
  <div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center">
    <a class="-translate-y-[1px] text-2xl font-medium" href="http://saurabhjha.github.io/"
      >Saurabh Jha</a
    >
    <div
      class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#f8f5d7'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 rtl:space-x-reverse dark:invert ltr:lg:ml-14 rtl:lg:mr-14 lg:mt-0 lg:items-center"
    >
      
      <a
        class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/saurabhjha"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./linkedin.svg)"
        href="https://linkedin.com/in/saurabh-jha-51706349"
        target="_blank"
        rel="me"
      >
        linkedin
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100vh-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"
    >
      

<article>
  <header class="mb-14">
    <h1 class="!my-0 pb-2.5">Implementing parsers</h1>

    
    <div class="text-xs antialiased opacity-60">
      
      <time>Jul 21, 2020</time>
      
      
      
      
    </div>
    
  </header>

  <section><h2 id="introduction">Introduction</h2>
<p>Once we have tokenized some program text, we need to check whether the tokens are in the correct sequence. For example, which of the following token
sequences are valid?</p>
<ol>
<li>Tokenization of &ldquo;32 + 4&rdquo;: &ldquo;&lt;number, 32&gt;, &lt;+, +&gt;, &lt;number, 4&gt;&rdquo;.</li>
<li>Tokenization of &ldquo;+ 32 4&rdquo;: &ldquo;&lt;+, +&gt;, &lt;number, 32&gt;, &lt;number, 4&gt;&rdquo;.</li>
</ol>
<p>Regular expressions are not powerful enough to make the choices like these.  The rules about which token sequences are valid constitute the
<em>syntax</em> of a programming language. In this article, we will develop the concepts and techniques of checking syntactic correctness of a program
text.</p>
<p>We will assume that the program text is already tokenized. Thus, our input is going to be a sequence of tokens. The tokens we will be
dealing with in this article are as follows.</p>
<ol>
<li>The token &ldquo;number&rdquo; represents positive integers.</li>
<li>The token &ldquo;id&rdquo; represents identifiers.</li>
<li>The symbols &ldquo;+&rdquo;, &ldquo;-&rdquo;, &ldquo;*&rdquo;, &ldquo;/&rdquo;, &ldquo;=&rdquo;, &ldquo;==&rdquo;, &ldquo;)&rdquo;, and &ldquo;(&rdquo; represent themselves.</li>
</ol>
<p>Here are some examples of raw inputs along with their tokenized represenations.</p>
<table>
  <thead>
    <tr>
      <th scope="col">Raw input</th>
      <th scope="col">Tokenized representation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>"123 + 13132"</td>
      <td>number + number</td>
    </tr>
    <tr>
      <td>"123 * 234 + 12"</td>
      <td>"number * number + number"</td>
    </tr>
    <tr>
      <td>"(978 * 13) / (123 - 12)"</td>
      <td>"(number * number) / (number - number)"</td>
    </tr>
  </tbody>
</table>
<p>For brevity, we will call a sequence of tokens a <em>string</em>.</p>
<h2 id="context-free-grammars">Context-free grammars</h2>
<p>We need a way to represent programming language syntax. Let&rsquo;s start with a simple example. Suppose we want to represent those
arithmetic expressions where two positive integers are separated by a &ldquo;+&rdquo; sign. We can represent this idea using the following notation.</p>
$$
  expr \rightarrow \underline{number} \underline{+} \underline{number}
$$<p>This is an example of a <em>production</em>. There are two parts separated by an arrow. The symbol &ldquo;expr&rdquo; on the left of the arrow is the <em>head</em>
of this production. The symbols &ldquo;number&rdquo;, &ldquo;+&rdquo;, and &ldquo;number&rdquo; on the right are collectively the <em>body</em> of this production. The underlined symbols
appear in the input and are called the <em>terminals</em>. Symbols that are not terminals are called the <em>non terminals</em>.</p>
<p>Only &ldquo;number + number&rdquo; conforms to the above production. To represent &ldquo;number + number + number&rdquo;, we need to write a new production.</p>
$$
  expr \rightarrow \underline{number} + \underline{number} + \underline{number}
$$<p>What if we want to represent an unbounded number of &ldquo;number&rdquo; tokens separated by &ldquo;+&rdquo; signs? The phrase &ldquo;an unbounded number&rdquo; suggests induction.
We need atleast two productions to represent an inductive definition.</p>
$$
\begin{align*}
  expr & \rightarrow expr \underline{+} \underline{number} \\
  expr & \rightarrow \underline{number}
\end{align*}
$$<p>In the above set of productions, the second production is the basis case and the first production is the inductive case. Before we can use this
set of productions to represent something like &ldquo;number + number + number&rdquo;, we need to define a new concept.</p>
<p>In a set of productions, if we designate a non terminal as a <em>start symbol</em>, we have a context-free grammar.</p>
<div class="definition">
  <p class="definition-title">Definition 1: Context-Free Grammar</p>
  <p>A context free grammar is a 4-tuple $\{V, \Sigma, P, S\}$ where:</p>
  <ol>
    <li>$V$ is a set of non terminals.</li>
    <li>$\Sigma$ is a set of terminals.</li>
    <li>$P$ is a set of productions.</li>
    <li>$S$ is a non terminal designated as a start symbol.</li>
  </ol>
</div>
<p>We can thus use our above pair of productions to create a context-free grammar.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Addition grammar</p>
  <p>Start symbol: expr</p>
  $$
  \begin{align*}
    expr & \rightarrow expr \underline{+} \underline{number} \\
    expr & \rightarrow \underline{number}
  \end{align*}
  $$
</div>
<p>In the above grammar:</p>
<ol>
  <li>$V = \{expr\}$,</li>
  <li>$\Sigma = \{number, +\}$,</li>
  <li>$P$ is the set of productions, and</li>
  <li>$S = expr$.</li>
</ol>
<p>A string is a member of a grammar if it can be <em>derived</em> using that grammar. Let us derive &ldquo;number + number + number&rdquo; using our addition grammar. We start
with the start symbol.</p>
$$
\begin{align*}
  expr
\end{align*}
$$<div>
  <p>
    We <i>apply a production</i> by replacing a non terminal with its body. So the application of
    $expr \rightarrow expr \underline{+} \underline{number}$ is this.
  </p>
</div>
$$
\begin{align*}
  expr + number
\end{align*}
$$<div>
  <p>On that $expr$ in the string, we apply the same production $expr \rightarrow expr \underline{+} \underline{number}$.</p>
</div>
$$
\begin{align*}
  expr + number + number
\end{align*}
$$<div>
  <p>Finally, we apply $expr \rightarrow \underline{number}$ on the $expr$ in the last string. The result is the string we wanted to derive.</p>
</div>
$$
\begin{align*}
  number + number + number
\end{align*}
$$<div class="definition">
  <p class="definition-title">Definition 2: Derivation</p>
  <p>The sequence of steps taken by a grammar to produce a string starting from the start symbol of the grammar is called a derivation.</p>
</div>
<p>The above derivation of &ldquo;number + number + number&rdquo; is this.</p>
$$
\begin{align*}
  & expr \\
  \implies & expr + number \\
  \implies & expr + number + number \\
  \implies & number + number + number
\end{align*}
$$<p>Context-free grammars describe languages. The langauges defined by context-free grammars are called <em>context-free languages</em>.</p>
<div>
  <p>
    One unknown in the above derivation is the choice of production to apply at each step. How did we know that we should apply
    $expr \rightarrow expr \underline{+} \underline{number}$ on all but the last step and $expr \rightarrow \underline{number}$ on the last step?
    This problem is central to syntax checking and we will address it over the course of the remaining article.
  </p>
</div>
<p>With context-free grammars, we have a notation to represent the syntactic elements of a programming language.</p>
<h2 id="reductions">Reductions</h2>
<p>In syntax checking, we are given a grammar and a string and we want to check whether the string is in the language of that grammar. We need to find the
derivation of that string using the grammar.</p>
<p>A more convinient way to look into this problem is to look at derivations in reverse. The above derivation of &ldquo;number + number + number&rdquo; in reverse
looks like this.</p>
$$
\begin{align*}
  & number + number + number \\
  \implies & expr + number + number \\
  \implies & expr + number \\
  \implies & expr
\end{align*}
$$<p>We are finding instances of production bodies in the string and replacing them with production heads. This process of replacing an instance of a
production body with a production head is called <em>reduction</em>. Reduction is the opposite of the application of a production. We can now
state the condition under which a string belongs to a context-free language.</p>
<div class="definition">
  <p class="definition-title">Definition 4: Criterion for a string to be derivable from a grammar</p>
  <p>
    A string can be derived from a grammar if we can reduce it to the start symbol of that grammar.
  </p>
</div>
<h2 id="extending-context-free-grammars">Extending context-free grammars</h2>
<p>The addition grammar is contrived. Because of that, we have not uncovered the full complexity of derivations and reductions.
Before moving further, we should learn about extending context-free grammars.</p>
<p>Context-free grammars are defined inductively. Thus, we can extend a context-free grammar by adding more inductive cases as productions.
Let&rsquo;s try to extend our arithemtic grammar. Right now, it can only handle the &ldquo;+&rdquo; operator.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Addition grammar</p>
  <p>Start symbol: expr</p>
  $$
  \begin{align*}
    expr & \rightarrow expr \underline{+} \underline{number} \\
    expr & \rightarrow \underline{number}
  \end{align*}
  $$
</div>
<p>We now want to add support for the &ldquo;*&rdquo; operator. We can do that by adding more productions to our addition grammar.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Addition and multiplication grammar</p>
  <p>Start symbol: expr</p>
  $$
  \begin{align*}
    expr & \rightarrow expr \underline{+} term \\
    expr & \rightarrow term \\
    term & \rightarrow term \underline{*} \underline{number} \\
    term & \rightarrow \underline{number}
  \end{align*}
  $$
</div>
<div>
  <p>
    We replaced the terminal $number$ in our addition grammar by a new non terminal $term$ and added basis and inductive productions for $term$.
  </p>
</div>
<p>One way to add more induction cases is to introduce new non terminals. This is what led us from addition grammar to addition and multiplication grammar.
Let us look at another example. If we want to handle parenthesized expressions like &ldquo;(123 + 12) * 3&rdquo;, we can extend our addition and multiplication grammar
like this.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Addition and multiplication with parenthesis</p>
  <p>Start symbol: expr</p>
  $$
  \begin{align*}
    expr & \rightarrow expr \underline{+} term \\
    expr & \rightarrow term \\
    term & \rightarrow term \underline{*} f\!actor \\
    term & \rightarrow f\!actor \\
    f\!actor & \rightarrow \underline{number} \\
    f\!actor & \rightarrow \underline{(} expr \underline{)}
  \end{align*}
  $$
</div>
<div>
  <p>
    We replaced $\underline{number}$ in addition and multiplication grammar by a new non terminal $f\!actor$ and added two new productions
    for $f\!actor$. The production $f\!actor \rightarrow \underline{number}$ is the basis case and $f\!actor \rightarrow (expr)$ is the
    inductive case.
  </p>
</div>
<p>We can add inductive cases to our grammar without introducing new non terminals by changing the way non terminals are arranged in production bodies.
Let us extend our grammar to handle &ldquo;&quot; and &ldquo;-&rdquo; operators.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Complete arithmetic grammar</p>
  <p>Start symbol: expr</p>
  $$
  \begin{align*}
    expr & \rightarrow expr \underline{+} term \\
    expr & \rightarrow expr \underline{-} term \\
    expr & \rightarrow term \\
    term & \rightarrow term \underline{*} f\!actor \\
    term & \rightarrow term \space \underline{/} \space f\!actor \\
    term & \rightarrow f\!actor \\
    f\!actor & \rightarrow \underline{number} \\
    f\!actor & \rightarrow \underline{(} expr \underline{)}
  \end{align*}
  $$
</div>
<div>
  <p>
    That is, we added two new productions, $expr \rightarrow expr \underline{-} term$ and $term \rightarrow term \space \underline{/} \space f\!actor$
    without changing anything else.
  </p>
</div>
<p>The complete arithmetic grammar is realistic enough for us to elucidate points we would otherwise have missed had we continued with our
original addition grammar.</p>
<h2 id="implementing-reductions">Implementing reductions</h2>
<p>Let us go back to the problem of implementing reductions. The implementations of reductions, and of grammars, are called parsers. The process of
reducing a string of tokens to the start symbol of a grammar is called <em>parsing</em>.</p>
<p>Let us reduce &ldquo;(number - number) * (number / number)&rdquo; using the complete arithmetic grammar. To get started, here is the derivation of &ldquo;(number - number) * (number / number)&rdquo; using the complete arithmetic grammar. Notice that at each step, we apply a production to the rightmost terminal. This technique is
called the <em>rightmost derivation</em>.</p>
<div>
  $$
  \begin{align*}
    & expr \\
    \implies & term \\
    \implies & term * f\!actor \\
    \implies & term * (expr) \\
    \implies & term * (term) \\
    \implies & term * (term \space / \space f\!actor) \\
    \implies & term * (term \space / \space number) \\
    \implies & term * (f\!actor \space / \space number) \\
    \implies & term * (number \space / \space number) \\
    \implies & f\!actor * (number \space / \space number) \\
    \implies & (expr) * (number \space / \space number) \\
    \implies & (expr - term) * (number \space / \space number) \\
    \implies & (expr - f\!actor) * (number \space / \space number) \\
    \implies & (expr - number) * (number \space / \space number) \\
    \implies & (term - number) * (number \space / \space number) \\
    \implies & (f\!actor - number) * (number \space / \space number) \\
    \implies & (number - number) * (number \space / \space number)
  \end{align*}
  $$
</div>
<p>Doing the derivation in reverse results in the reduction of the input to the start symbol.</p>
<div>
  $$
  \begin{align*}
    & (number - number) * (number \space / \space number) \\
    \implies & (f\!actor - number) * (number \space / \space number) \\
    \implies & (term - number) * (number \space / \space number) \\
    \implies & (expr - number) * (number \space / \space number) \\
    \implies & (expr - f\!actor) * (number \space / \space number) \\
    \implies & (expr - term) * (number \space / \space number) \\
    \implies & (expr) * (number \space / \space number) \\
    \implies & f\!actor * (number \space / \space number) \\
    \implies & term * (number \space / \space number) \\
    \implies & term * (number \space / \space number) \\
    \implies & term * (f\!actor \space / \space number) \\
    \implies & term * (term \space / \space number) \\
    \implies & term * (term \space / \space f\!actor) \\
    \implies & term * (term) \\
    \implies & term * (expr) \\
    \implies & term * f\!actor \\
    \implies & term \\
    \implies & expr
  \end{align*}
  $$
</div>
<p>Because we already know how this particular input is reduced, we can use the above steps as our guide and focus on the data structures and the algorithms
we can use to represent this process. We will then use those techniques to parse new inputs.</p>
<p>Suppose the input is an array of tokens and we have an empty stack. In the following illustrations, the top of the stack is on the right. The initial
state looks like this.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td class="text-right">$(number - number) * (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<p>We will apply one of the following two operations at each step.</p>
<ol>
<li>We shift a token onto the stack. This is called performing a <em>shift</em>.</li>
<li>We identify the stack contents with a production body and perform a reduction on part or all of the stack. This is called performing a <em>reduce</em>.</li>
</ol>
<p>The parser variant we are considering is called a <em>shift-reduce parser.</em></p>
<div>
  <p>Once we shift the first token, we have the following parser state.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$($</td>
      <td class="text-right">$number - number) * (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<p>Let us shift one more token on to the stack.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(number$</td>
      <td class="text-right">$- \space number) * (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    Before doing any more shifts, we need to reduce the top token of the stack $number$ using $f\!actor \rightarrow \underline{number}$. This is suggested
    by the reduction steps we described above.
  </p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(f\!actor$</td>
      <td class="text-right">$- \space number) * (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>Looking at the above reduction steps, we need to reduce again, this time with $term \rightarrow f\!actor$.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(term$</td>
      <td class="text-right">$- \space number) * (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>Using the above reduction steps again as our guide, we do another reduce using $expr \rightarrow term$.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr$</td>
      <td class="text-right">$- \space number) * (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<p>We now do two shifts.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr\space-$</td>
      <td class="text-right">$number)* (number \space / \space number)$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr - number$</td>
      <td class="text-right">$)* (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>We next do two reductions on the top symbol, one using $f\!actor \rightarrow \underline{number}$ and another using $term \rightarrow f\!actor$.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr - f\!actor$</td>
      <td class="text-right">$)* (number \space / \space number)$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr - term$</td>
      <td class="text-right">$)* (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    So far, we have been reducing only the top symbol. Our next reduction is going to use the top three tokens using the production
    $expr \rightarrow expr \underline{-} term$.
  </p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr$</td>
      <td class="text-right">$)* (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<p>We shift again.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr)$</td>
      <td class="text-right">$* \space (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>We now reduce the entire stack contents using the production $f\!actor \rightarrow \underline{(}expr\underline{)}$.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$f\!actor$</td>
      <td class="text-right">$* \space (number \space / \space number)$</td>
    </tr>
  </tbody>
</table>
<p>In the steps we have executed so far, we notice two things.</p>
<ol>
<li>We need to decide whether to shift or to reduce at each step.</li>
<li>We need to select a production whenever we perform a reduce.</li>
</ol>
<p>We continue executing actions similar to above till we have only the start symbol on the stack. We add a new column of explanations for each of these steps.
On each row, the explanation is the action we do to get the next row.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
      <th class="text-center">Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$f\!actor$</td>
      <td class="text-right">$* \space (number \space / \space number)$</td>
      <td>reduce using $term \rightarrow f\!actor$</td>
    </tr>
    <tr>
      <td class="text-left">$term$</td>
      <td class="text-right">$* \space (number \space / \space number)$</td>
      <td>shift $*$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space *$</td>
      <td class="text-right">$(number \space / \space number)$</td>
      <td>shift $($</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * ($</td>
      <td class="text-right">$number \space / \space number)$</td>
      <td>shift $number$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (number$</td>
      <td class="text-right">$/ \space number)$</td>
      <td>reduce using $f\!actor \rightarrow \underline{number}$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (f\!actor$</td>
      <td class="text-right">$/ \space number)$</td>
      <td>reduce using $term \rightarrow f\!actor$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (term$</td>
      <td class="text-right">$/ \space number)$</td>
      <td>shift $/$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (term \space /$</td>
      <td class="text-right">$number)$</td>
      <td>shift $number$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (term \space / \space number$</td>
      <td class="text-right">$)$</td>
      <td>reduce using $f\!actor \rightarrow \underline{number}$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (term \space / \space f\!actor$</td>
      <td class="text-right">$)$</td>
      <td>reduce using $term \rightarrow term \space \underline{/} \space f\!actor$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (term$</td>
      <td class="text-right">$)$</td>
      <td>reduce using $expr \rightarrow term$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (expr$</td>
      <td class="text-right">$)$</td>
      <td>shift $)$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * (expr)$</td>
      <td class="text-right"></td>
      <td>reduce using $f\!actor \rightarrow (expr)$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space * f\!actor$</td>
      <td class="text-right"></td>
      <td>reduce using $term \rightarrow term \underline{*} f\!actor$</td>
    </tr>
    <tr>
      <td class="text-left">$term$</td>
      <td class="text-right"></td>
      <td>reduce using $expr \rightarrow term$</td>
    </tr>
    <tr>
      <td class="text-left">$expr$</td>
      <td class="text-right"></td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>We now have the mechanism to implement parsing. We either do a shift or a reduce using a stack and an array of tokens. But the above implementation
makes decisions at each step and we don&rsquo;t yet know how to make those decisions. The decisions are:</p>
<ol>
<li>Should we shift or should we reduce?</li>
<li>If we are reducing, which production should we use?</li>
</ol>
<p>In other words, we have the mechanisms in place but not the <em>policies</em> to drive those mechanisms. We will focus next on changing our above implementation
so that it can make those decisions.</p>
<h2 id="implementing-parsing-decisions">Implementing parsing decisions</h2>
<p>What are the decision inputs at each step? We have two pieces of information.</p>
<ol>
<li>The entire stack that is read from right to left.</li>
<li>The next token in the array of tokens that we are parsing. In other words, we have a <em>lookahead</em> of one symbol.</li>
</ol>
<p>To see how these information pieces can be used to make a decision, let&rsquo;s look at the reduction of &ldquo;number + number * number&rdquo;.</p>
<div>
  $$
  \begin{align*}
    & number + number * number \\
    \implies & f\!actor + number * number \\
    \implies & term + number * number \\
    \implies & expr + number * number \\
    \implies & expr + f\!actor * number \\
    \implies & expr + term * number \\
    \implies & expr + term * f\!actor \\
    \implies & expr + term \\
    \implies & expr
  \end{align*}
  $$
</div>
<div>
  <p>
    We notice that terminals follow non terminals at some derivation steps. For example, terminal $+$ follows non terminals $term$, $f\!actor$,
    and $expr$. At one point, the parser state would look like this.
  </p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(f\!actor$</td>
      <td class="text-right">$+ number * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    We say that we can reduce $f\!actor$ to $term$ only if $+$ can follow $term$ in a derivation step. That's indeed the case and the parser proceeds.
  </p>
</div>
<p>Therefore, to make progress with the parser implementation, we need to find the terminals that can follow each non terminal of a grammar during a derivation.</p>
<div class="definition">
  <p class="definition-title">Definition 5: Follow set of a non terminal</p>
  <p>The follow set of a non terminal is the set of terminals that can follow it in a derivation step.</p>
</div>
<p>What happens if a non terminal is followed by another non terminal in a parser state? That&rsquo;s not possible in our arithmetic grammar above because all
non terminals are followed by terminals so let&rsquo;s create a new grammar to answer this question.</p>
<p>Suppose we want to express C-like declaration statements like &ldquo;int foo, bar;&rdquo; or &ldquo;float temperature;&rdquo;. Here&rsquo;s a grammar to represent declaration statements.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Declaration statement grammar</p>
  <p>Start symbol: declaration</p>
  $$
  \begin{align*}
    declaration & \rightarrow type \space variables\_list \space \underline{;} \\
    type & \rightarrow \underline{int} \\
    type & \rightarrow \underline{f\!loat} \\
    variables\_list & \rightarrow variables\_list \space \underline{,} \underline{variable} \\
    variablies\_list & \rightarrow \underline{variable}
  \end{align*}
  $$
</div>
<div>
  <p>
    In the first production, we have a non terminal $type$ followed by another non terminal $variables\_list$. How can we compute
    the follow set of $type$? Solving this problem requires clarifying what do non terminals represent. We will first clarify what non terminals
    are before going back to the follow sets.
  </p>
</div>
<div>
  <p>
    <i>Every non terminal of a grammar derives strings</i>. In our declaration statements grammar, non terminal $variables\_list$ derives strings like these.
    <ul>
      <li>"variable"</li>
      <li>"variable, variable"</li>
      <li>"variable, variable, variable"</li>
    </ul>
  </p>
</div>
<p>We can now define the concept of the <em>first set</em> of a grammar symbol.</p>
<div class="definition">
  <p class="definition-title">Definition 6: First set of a grammar symbol</p>
  <p>The first set of a non terminal is the set of all possible terminals that can start the strings derivable from that non terminal.</p>
  <p>The first set of a terminal is that terminal itself.</p>
</div>
<p>Let us look at a couple of examples to make this clear.</p>
<div>
  <p>In our arithmetic grammar, some of the strings derivable from the non terminal $term$ look like these.</p>
  <ul>
    <li>"number"</li>
    <li>"number * number"</li>
    <li>"(number) * number"</li>
  </ul>
  <p>
    These strings start with either $number$ or $($. Thus, the first set of $term$ is $\{number, \space (\space\}$.
  </p>
</div>
<div>
  <p>In our declaration grammar, some of the strings derivable from the non terminal $variables\_list$ look like these.</p>
  <ul>
    <li>"variable"</li>
    <li>"variable, variable"</li>
    <li>"variable, variable, variable"</li>
  </ul>
  <p>Thus, the first set of $variables\_list$ is $\{variable\}$.</p>
</div>
<p>We can now design an algorithm to compute the first sets. The definition suggests a recursive algorithm. The basis case is when the grammar symbol we
are computing the first set of is a terminal. The recursive case is when the grammar symbol is a non terminal.</p>
<div>
  <p>
    To come up with an algorithm, let us look at some examples of how strings are derived from a non terminal. We will use our declaration grammar and
    compute the first set of the non terminal $declaration$. Some of the strings derived from $declaration$, along with their rightmost derivations,
    look like these.
  </p>
  <ul>
    <li>
      String: "float variable;"<br/>
      Derivation: $declaration \Rightarrow type \space variables\_list; \Rightarrow type \space variable; \Rightarrow f\!loat \space variable; $
    </li>
    <li>
      String: "int variable, variable;"<br/>
      Derivation: $declaration \Rightarrow type \space variables\_list; \Rightarrow type \space variables\_list, \space variable;
      \Rightarrow type \space variable, \space variable; \Rightarrow int \space variable, \space variable; $
    </li>
  </ul>
</div>
<div>
  <p>Here is how we can compute the first set of $declaration$.</p>
</div>
<ul>
  <li>Because the non terminal $type$ derives two single length strings, $int$ and $f\!loat$, and nothing else, the first set of
  $type$ is $\{int, f\!loat\}$.</li>
  <li>
    Because of the production $declaration \rightarrow type \space variables\_list\underline{;}$, every string derivable from $declaration$ must start
    with something that is derived from $type$. Thus, the first set of $type$ is a subset of the first set of $declaration$. Since there are no other
    productions with $declaration$ as the head, the first set of $declaration$ equals the first set of $type$.
  </li>
</ul>
<p>We are now in a position to write down a recursive algorithm to compute first set.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">compute_first_set</span>(grammar_symbol):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> grammar_symbol <span style="color:#f92672">is</span> a terminal:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Basis case</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {grammar_symbol}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Recursive case</span>
</span></span><span style="display:flex;"><span>    first_set <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    productions_of_grammar_symbol <span style="color:#f92672">=</span> get_all_productions_of_grammar_symbol(grammar_symbol)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> production <span style="color:#f92672">in</span> productions_of_grammar_symbol:
</span></span><span style="display:flex;"><span>      first_symbol_of_production_body <span style="color:#f92672">=</span> get_first_symbol_of_production_body(production)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> first_symbol_of_production_body <span style="color:#f92672">!=</span> grammar_symbol:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Recurse</span>
</span></span><span style="display:flex;"><span>        first_set_of_body_symbol <span style="color:#f92672">=</span> compute_first_set(first_symbol_of_production_body)
</span></span><span style="display:flex;"><span>        first_set<span style="color:#f92672">.</span>union_with(first_set_of_body_symbol)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> first_set
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div>
  <p>
    Let us try to find the first set of $declaration$ in the declaration grammar using this algorithm. We repeat the grammar below.
  </p>
</div>
<div class="grammar-box">
  <p class="grammar-box-title">Declaration statement grammar</p>
  <p>Start symbol: declaration</p>
  $$
  \begin{align*}
    declaration & \rightarrow type \space variables\_list \space \underline{;} \\
    type & \rightarrow \underline{int} \\
    type & \rightarrow \underline{f\!loat} \\
    variables\_list & \rightarrow variables\_list \space \underline{,} \underline{variable} \\
    variablies\_list & \rightarrow \underline{variable}
  \end{align*}
  $$
</div>
<p>The execution looks like this.</p>
<div>
  $$
  \begin{align*}
    & compute\_f\!irst\_set(declaration) \\
    \implies & \{\} \cup compute\_f\!irst\_set(type) \\
    \implies & \{\} \cup \{\} \cup compute\_f\!irst\_set(int) \cup compute\_f\!irst\_set(f\!loat) \\
    \implies & \{\} \cup \{\} \cup \{int\} \cup compute\_f\!irst\_set(f\!loat) \\
    \implies & \{\} \cup \{\} \cup \{int\} \cup \{f\!loat\} \\
    \implies & \{int, f\!loat\}
  \end{align*}
  $$
</div>
<p>Let us do another example, this time with our arithmetic grammar.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Complete arithmetic grammar</p>
  <p>Start symbol: expr</p>
  $$
  \begin{align*}
    expr & \rightarrow expr \underline{+} term \\
    expr & \rightarrow expr \underline{-} term \\
    expr & \rightarrow term \\
    term & \rightarrow term \underline{*} f\!actor \\
    term & \rightarrow term \space \underline{/} \space f\!actor \\
    term & \rightarrow f\!actor \\
    f\!actor & \rightarrow \underline{number} \\
    f\!actor & \rightarrow \underline{(} expr \underline{)}
  \end{align*}
  $$
</div>
<p>The execution looks like this.</p>
<div>
  $$
  \begin{align*}
    & compute\_f\!irst\_set(expr) \\
    \implies & \{\} \cup compute\_f\!irst\_set(term) \\
    \implies & \{\} \cup \{\} \cup compute\_f\!irst\_set(f\!actor) \\
    \implies & \{\} \cup \{\} \cup \{\} \cup compute\_f\!irst\_set(number) \cup compute\_f\!irst\_set(() \\
    \implies & \{\} \cup \{\} \cup \{\} \cup \{number\} \cup \{(\} \\
    \implies & \{number, (\} \\
  \end{align*}
  $$
</div>
<p>We can now go back to designing an algorithm for computing follow sets. There are two scenarios under which a terminal can be in the follow set of a
non terminal.</p>
<div>
  <p>
    The first scenario is when a non terminal is followed by another grammar symbol in a production body. In that case, the first set of the following
    grammar symbol is included in the follow set of the non terminal. For example, in our above declaration grammar, the first set of $variables\_list$
    is included in the follow set of $type$.
  </p>
</div>
<div>
  <p>
    The second scenario is when a non terminal is the last symbol of a production body. In that case, the follow set of the head of the production is
    included in the follow set of that non terminal. For example, in our above arithmetic grammar, the follow set of $term$ is included in the
    follow set of $f\!actor$. To see how that could be true, consider an example derivation step using the arithmetic grammar
    $ expr + number \implies expr + term + number$. Because of the production $expr \rightarrow expr + term$, every terminal that follows
    $expr$ can also follow $term$. Hence, the follow set of $term$ must include the follow set of $expr$.
  </p>
</div>
<p>We now have enough information to write an algorithm to compute follow sets.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">compute_follow_set</span>(non_terminal):
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  follow_set <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> production <span style="color:#f92672">in</span> productions {
</span></span><span style="display:flex;"><span>    production_body <span style="color:#f92672">=</span> production<span style="color:#f92672">.</span>get_body()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> the given non terminal does <span style="color:#f92672">not</span> appear <span style="color:#f92672">in</span> the production body:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> the given non terminal <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> the last symbol of the production_body:
</span></span><span style="display:flex;"><span>      follow_set<span style="color:#f92672">.</span>union_with(compute_first_set(symbol following the given non terminal))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>      production_head <span style="color:#f92672">=</span> production<span style="color:#f92672">.</span>get_head()
</span></span><span style="display:flex;"><span>      follow_set<span style="color:#f92672">.</span>union_with(compute_follow_set(production_head))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> follow_set
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Let us try the above algorithm on our arithmetic grammar which is repeated below.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Complete arithmetic grammar</p>
  <p>Start symbol: expr</p>
  $$
  \begin{align*}
    expr & \rightarrow expr \underline{+} term \\
    expr & \rightarrow expr \underline{-} term \\
    expr & \rightarrow term \\
    term & \rightarrow term \underline{*} f\!actor \\
    term & \rightarrow term \space \underline{/} \space f\!actor \\
    term & \rightarrow f\!actor \\
    f\!actor & \rightarrow \underline{number} \\
    f\!actor & \rightarrow \underline{(} expr \underline{)}
  \end{align*}
  $$
</div>
<p>Here is the execution of &ldquo;compute_follow_set(factor)&rdquo;.</p>
<div>
  $$
  \begin{align*}
    & compute\_f\!ollow\_set(f\!actor) \\
    \implies & \{\} \cup compute\_f\!ollow\_set(term) \\
    \implies & \{\} \cup \{\} \cup compute\_f\!irst\_set(*) \cup compute\_f\!irst\_set(/) \cup compute\_f\!ollow\_set(expr) \\
    \implies & \{\} \cup \{\} \cup compute\_f\!irst\_set(*) \cup compute\_f\!irst\_set(/) \cup compute\_f\!irst\_set(+) \cup compute\_f\!irst\_set(-) \cup compute\_f\!irst\_set(() \\
    \implies & \{\} \cup \{\} \cup \{*\} \cup \{/\} \cup \{+\} \cup \{-\} \cup \{(\} \\
    \implies & \{/, *, +, -, (\}
  \end{align*}
  $$
</div>
<p>We can now go back to making decisions at parsing steps. We can now answer both questions we posed earlier.
The statements below cannot be justified in a formal way and hence we will call them heuristics. These heuristics will always work for the grammars we
will consider and they work for grammars that common occur in programming language syntax specifications.</p>
<ol>
<li>The first question was about deciding whether to shift or to reduce at each parsing step. The answer is this. If we reduce the top stack contents and
the resulting non terminal has the following token in its follow set, we reduce. Otherwise, we shift.</li>
<li>If we can choose between multiple productions, we choose the one which reduces the maximum of the stack contents.</li>
</ol>
<p>Let&rsquo;s see an example of how these heuristics can be applied in practice. We will parse &ldquo;(number - number) * number&rdquo; using our arithmetic grammar.
Before we do our parsing, we should write down the follow sets of each non terminal.</p>
<div>
  $$
  \begin{align*}
    & compute\_f\!ollow\_set(expr) = \{+, -, )\} \\
    & compute\_f\!ollow\_set(term) = \{+, -, *, /, )\} \\
    & compute\_f\!ollow\_set(f\!actor) = \{+, -, *, /, )\} \\
  \end{align*}
  $$
</div>
<p>The initial state of the parser is this.</p>
<table class="">
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td class="text-right">$(number - number) * number$</td>
    </tr>
  </tbody>
</table>
<p>There is nothing on the stack so we do a shift.</p>
<table class="">
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$($</td>
      <td class="text-right">$number - number) * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>No non terminal has $number$ in its follow set so we shift again.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(number$</td>
      <td class="text-right">$-\space number) * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    $-$ is in the follow set of $f\!actor$ and the production $f\!actor \rightarrow number$ matches the top symbol of the stack.
    Therefore, we use our first heuristic and give preference to reduce over shift by applying $f\!actor \rightarrow number$.
  </p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(f\!actor$</td>
      <td class="text-right">$-\space number) * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    Since $-$ is in the follow set of $term$ and the production $term \rightarrow f\!actor$ matches the top symbol of the stack, we apply
    $term \rightarrow f\!actor$.
  </p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(term$</td>
      <td class="text-right">$-\space number) * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    $-$ is also the follow set of $expr$ and we can apply $expr \rightarrow term$.
  </p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr$</td>
      <td class="text-right">$-\space number) * number$</td>
    </tr>
  </tbody>
</table>
<p>We cannot do any more reductions so we do a shift.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr \space -$</td>
      <td class="text-right">$number) * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>We do a shift again since $number$ is not in the follow set of any non terminal.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr \space - number$</td>
      <td class="text-right">$) * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>Now, $)$ is in the follow set of $f\!actor$. Thus, we reduce the top symbol using $f\!actor \rightarrow number$.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr \space - f\!actor$</td>
      <td class="text-right">$) * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>$)$ is in the follow set of $term$ as well so we apply $term \rightarrow f\!actor$ to the top symbol of the stack.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr \space - term$</td>
      <td class="text-right">$) * number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    We know that $)$ is in the follow set of $expr$. But we have two choices of productions that we can apply: $expr \rightarrow term$ and
    $expr \rightarrow expr - term$. Following our second heuristic, we should match the maximum of the stack contents that we can and therefore apply
    $expr \rightarrow expr -term$ on the top three symbols of the stack.
  </p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr$</td>
      <td class="text-right">$) * number$</td>
    </tr>
  </tbody>
</table>
<p>We cannot do any more reductions so we shift.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$(expr)$</td>
      <td class="text-right">$*\space number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>$*$ is in the follow set of $f\!actor$ and $f\!actor \rightarrow (expr)$ matches all of the stack contents. We can do a reduction.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$f\!actor$</td>
      <td class="text-right">$* \space number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>$*$ is in the follow set of $term$. After applying $term \rightarrow f\!actor$, we get the following.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$term$</td>
      <td class="text-right">$* \space number$</td>
    </tr>
  </tbody>
</table>
<p>We cannot do any more reductions so we do a shift.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$term \space *$</td>
      <td class="text-right">$number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>We do a shift again since $number$ is not in the follow set of any non terminal.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$term \space * number$</td>
      <td class="text-right"></td>
    </tr>
  </tbody>
</table>
<p>We are stuck now. We cannot do any more moves but we still haven&rsquo;t reduced the stack contents to the start symbol. We need to introduce more features
into our parser to get past this stuck state.</p>
<p>We introduce the convention that every input is ended by $$$. The $$$ symbol is not a part of the grammar and is introduced to mark the end
of the inputs we will be parsing.</p>
<p>
  Suppose we start with the input $number + number$. With our arithmetic grammar, it will be reduced to $expr \$$.
  In general, every start symbol is going to have $\$$ in its follow set. Thus, the follow sets of arithmetic
  grammar that we computed above need revision.
</p>
<div>
  $$
  \begin{align*}
    & compute\_f\!ollow\_set(expr) = \{+, -, ), \$\} \\
    & compute\_f\!ollow\_set(term) = \{+, -, *, /, ), \$\} \\
    & compute\_f\!ollow\_set(f\!actor) = \{+, -, *, /, ), \$\} \\
  \end{align*}
  $$
</div>
<p>We now replay all the parsing steps we did above.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left"></td>
      <td class="text-right">$(number - number) * number\space$$</td>
    </tr>
    <tr>
      <td class="text-left">$($</td>
      <td class="text-right">$number - number) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(number$</td>
      <td class="text-right">$-\space number) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(f\!actor$</td>
      <td class="text-right">$-\space number) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(term$</td>
      <td class="text-right">$-\space number) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr$</td>
      <td class="text-right">$-\space number) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr\space -$</td>
      <td class="text-right">$number) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr - number$</td>
      <td class="text-right">$) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr - f\!actor$</td>
      <td class="text-right">$) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr - term$</td>
      <td class="text-right">$) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr$</td>
      <td class="text-right">$) * number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$(expr)$</td>
      <td class="text-right">$ *\space number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$f\!actor$</td>
      <td class="text-right">$ *\space number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$term$</td>
      <td class="text-right">$ *\space number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$term \space *$</td>
      <td class="text-right">$number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$term * number$</td>
      <td class="text-right">$\space $$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>We have $\$$ in the follow set of $f\!actor$. We thus apply $f\!actor \rightarrow number$.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$term * f\!actor$</td>
      <td class="text-right">$\space $$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>We have $\$$ in the follow set of $term$ and we can match all of the stack contents using $term \rightarrow term * f\!actor$.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$term$</td>
      <td class="text-right">$\space $$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>Finally, $\$$ is in the follow set of $expr$. We can apply $expr \rightarrow term$.</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$expr$</td>
      <td class="text-right">$\space $$</td>
    </tr>
  </tbody>
</table>
<p>Since we have reduced the input to the start symbol, our parsing has finished succesfully.</p>
<p>We now have a definite framework to execute parsing actions and make parsing decisions. But we need to make the above mechanisms and policies more amenable
to implementation. In the next section, we will recast the above framework as a graph problem.</p>
<h2 id="implementing-parsers-using-automata">Implementing parsers using automata</h2>
<p>In the last section, we arrived at a framework for making parsing decisions. We now have all the ingredients we need to construct a parser programmatically
given a context-free grammar. In this section, we will implement context-free grammars using a specific type of automaton.</p>
<p>Let us start by doing a quick review of the basics of finite automata. A finite automaton is a labelled directed graph where the vertices of the
graph are called the states and the edges are called the transitions. Each finite automaton has:</p>
<ol>
<li>A set of states.</li>
<li>A state identified as a start state.</li>
<li>A set of states identified as final states.</li>
<li>An alphabet which is the set of symbols that can label transitions.</li>
<li>A transition function which takes a state and an alphabet symbol as inputs and outputs a set of states.</li>
</ol>
<p>Here is an example.</p>
<p><img src="/img/compilers/second_automata_epsilon.png" alt="Second automata epsilon"></p>
<p>The automaton makes moves on a given string. For example, for string &ldquo;ab&rdquo;, the above automaton makes the following moves.</p>
<div>
  $$
    \{1,2,5,8\} \xrightarrow a \{3\} \xrightarrow b \{4\}
  $$
</div>
<p>How can we use finite automata to track parser state? To examine that, let us go back to the simplest grammar we had at the beginning.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Addition with two operands grammar</p>
  <p>Start symbol: expr</p>
  $$
  \begin{align*}
    expr & \rightarrow \underline{number} \underline{+} \underline{number} \\
  \end{align*}
  $$
</div>
<p>We can construct a finite automaton that recognises the body of the production.</p>
<p><img src="/img/compilers/grammar_two_operand_body_automaton.png" alt="Two operand body automaton"></p>
<p>We can also construct a finite automaton to recognise the head of the production.</p>
<p><img src="/img/compilers/grammar_two_operand_head_automaton.png" alt="Two operand head automaton"></p>
<p>When we are scanning some input from left to right, we can use the body automaton to keep track of where we are in the input. After we have reduced
the input to the production head, we can use our head automaton to see if the reduced string is correct.</p>
<p>We can track where we are in a production with a dot in the production body. Here are some examples.</p>
<div>
  $$
  \begin{align*}
    expr \rightarrow .\underline{number} \underline{+} \underline{number} \\
    expr \rightarrow \underline{number} . \underline{+} \underline{number} \\
  \end{align*}
  $$
</div>
<p>It is formally defined like this.</p>
<div class="definition">
  <p class="definition-title">Definition 7: Production item</p>
  <p>A production item is a production with a dot before a symbol in the body.</p>
</div>
<p>We can now redraw our body automaton using production items.</p>
<p><img src="/img/compilers/grammar_two_operand_lr_body.png" alt="Two operand LR body automaton"></p>
<div>
  <p>
    If a string takes the above automaton to state 3, we should reduce using the production $expr \rightarrow \underline{number} \underline{+} \underline{number}$. How can we check whether we have correctly reduced to the head of the production? We can construct a new automaton for the head. To make that more
    convenient,
    we augment our grammar with a new production and a new start symbol.
  </p>
</div>
<div class="grammar-box">
  <p class="grammar-box-title">Augmented addition with two operands grammar</p>
  <p>Start symbol: expr'</p>
  $$
  \begin{align*}
    expr' & \rightarrow expr \\
    expr & \rightarrow \underline{number} \underline{+} \underline{number} \\
  \end{align*}
  $$
</div>
<p>We can now make an automaton to recoginse the string &ldquo;expr&rdquo;. Let us call it the head automaton.</p>
<p><img src="/img/compilers/grammar_two_operand_lr_head.png" alt="Two operand LR head automaton"></p>
<p>The sequence of things that need to happen for our addition grammar to accept a string is this.</p>
<ol>
<li>The string takes the body automaton to state 3.</li>
<li>Once we reach the state 3, we reduce using the addition grammar production.</li>
<li>We now have the head of the production as the input string. We confirm that by executing the head automaton using the reduced string and checking
whether it goes to state 1.</li>
</ol>
<p>There are gaps between these steps that we need to fill. How can we construct a single automaton to execute the above steps. We somehow have to do this.</p>
<ol>
<li>We traverse the body automaton using the input string.</li>
<li>Once the body automaton scans the input string corresponding the body of a production, we do a reduction.</li>
<li>We traverse the head automaton using the reduced string.</li>
</ol>
<p>The way to achieve this is by <em>pushing the current state of the automaton on a stack after each transition</em>. Earlier, we implicitely tracked our
current state using a single variable. If we push the current state after each transition to a stack, it would enable us to &ldquo;revert&rdquo; the steps
the automaton took.</p>
<p>Let us now see how can we construct an automaton for a grammar. We start with the start symbol production.</p>
<p><img src="/img/compilers/grammar_two_operand_start_state.png" alt="Two operand start state automaton"></p>
<div>
  <p>
    When we are at state 0, we can either see $expr$ or something that is derived from $expr$. So we need to have two transitions out of state 0,
    one with the label $expr$ and one with an $\epsilon$-transition to a "sub-automaton" to recognise the body of $expr$, which is $number + number$.
  </p>
</div>
<p><img src="/img/compilers/grammar_two_operand_complete_automaton.png" alt="Two operand complete automaton"></p>
<p>Let us try to parse &ldquo;number + number&rdquo; using the above automaton and a stack. We represent the stack contents by writing down the elements
of the stack seperated by commas such that the top of the stack is on the right. Initially, the stack consists of the start state of the automaton.</p>
<div>
  $$
    \{0, 2\}
  $$
</div>
<p>After reading &ldquo;number&rdquo;, the automaton goes to state 3. We push that state on to the stack.</p>
<div>
  $$
    \{0, 2\}, \{3\}
  $$
</div>
<p>After reading &ldquo;+&rdquo;, we push state 4 onto the stack.</p>
<div>
  $$
    \{0, 2\}, \{3\}, \{4\}
  $$
</div>
<p>Finally, we ready &ldquo;number&rdquo; and the new stack state looks like this.</p>
<div>
  $$
    \{0, 2\}, \{3\}, \{4\}, \{5\}
  $$
</div>
<div>
  <p>
    We now do a reduce using the production $expr \rightarrow \underline{number} \underline{+} \underline{number}$.
    When we do a reduce, we pop as many elements from the stack as there are symbols in the body. That leads us back to the state we were in when we started
    parsing the production body. Since the length of the body of this production is three, we pop three elements from the stack. The current stack looks
    like this.
  </p>
</div>
<div>
  $$
    \{0, 2\}
  $$
</div>
<p>We have reduced the string to &ldquo;expr&rdquo;. We now restart the automaton with &ldquo;expr&rdquo; as the input. The stack looks like this after reading &ldquo;expr&rdquo;.</p>
<div>
  $$
    \{0, 2\}, \{1\}
  $$
</div>
<p>The current state of the automaton corresponds to the input reduced to the start symbol. Hence, the automaton has parsed &ldquo;number + number&rdquo; succesfully.</p>
<p>Let us try a slightly more complex grammar. We augment our original complete addition grammar with a new start symbol.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Augmented addition grammar</p>
  <p>Start symbol: expr'</p>
  $$
  \begin{align*}
    expr' & \rightarrow expr \\
    expr & \rightarrow expr \underline{+} \underline{number} \\
    expr & \rightarrow \underline{number}
  \end{align*}
  $$
</div>
<p>As above, we start with the start symbol production state.</p>
<p><img src="/img/compilers/grammar_add_all_start_state.png" alt="Add all start state"></p>
<div>
  <p>
    Let us focus first on computing the $\epsilon$-closure of this state. An $\epsilon$-closure of a state is that state itself along with all
    the other states reachable from that state following $\epsilon$ moves alone. In our context, it means that if the dot is before a non terminal,
    we can either see that non terminal or some string derivable from that non terminal. So we add as many $\epsilon$ transitions as there are
    productions of the non-terminal that appears next to the dot.
  </p>
</div>
<p><img src="/img/compilers/grammar_add_all_start_state.png" alt="Add all start state"></p>
<div>
  <p>
    From state 1, we do not need to compute $\epsilon$-closure for the productions of $expr$ since we have already included all $expr$ productions
    in states 0, 1, and 2.
  </p>
</div>
<p>Starting from state 1, we can include all the states to process &ldquo;expr + number&rdquo;.</p>
<p><img src="/img/compilers/grammar_add_all_partial.png" alt="Add all partial"></p>
<p>We can similarly add the states to process &ldquo;number&rdquo; from state 2, and to process &ldquo;expr&rdquo; from state 0.</p>
<p><img src="/img/compilers/grammar_add_all_complete.png" alt="Add all complete"></p>
<p>Let&rsquo;s parse &ldquo;number + number + number&rdquo; using our above automaton. We will write the stack states on the left and the input that remains
to be parsed on the right. The start state looks like this.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}$</td>
      <td class="text-right">$number + number + number$</td>
    </tr>
  </tbody>
</table>
<p>After reading the first token, we reach state 6. The parser state now looks like this.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{6\}$</td>
      <td class="text-right">$+\space number + number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    State 6 indicates that we should reduce using $expr \rightarrow number$. We now need to "revise our history" and transition to the state we would have
    reached after reading "expr" from $\{0, 1, 2\}$ instead of "number". We do two things.
  </p>
  <ol>
    <li>We pop as many elements from the stack as there are symbols in the body. In our case, we pop off one state.</li>
    <li>
      Now we know the state we originally had and we know the string we want to process, which is the head $expr$. We therefore push the state
      reachable from 0 using $expr$. The parser state looks like this now.
    </li>
  </ol>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}$</td>
      <td class="text-right">$+\space number + number$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    State 7 suggests that we should do a reduce using $expr' \rightarrow expr$. But we shouldn't because <i>+ is not in the
    follow set of $expr'$</i>. To make further progress, we should compute the follow sets of $expr'$ and $expr$. We should also re-introduce the
    convention of terminating the inputs by the symbol "$". The follow sets look like these.
  </p>
</div>
<div>
  $$
  \begin{align*}
    & compute\_f\!ollow\_set(expr') = \{\$\} \\
    & compute\_f\!ollow\_set(expr) = \{\$, +\}
  \end{align*}
  $$
</div>
<p>Let us continue processing our string using the automaton. There is nothing we can do from state 7 but from state 3, we can follow a transition to state 4
using &ldquo;+&rdquo;.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}, \{4\}$</td>
      <td class="text-right">$number + number \space $$</td>
    </tr>
  </tbody>
</table>
<p>From 4, we can go to 5 following &ldquo;number&rdquo; transition.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}, \{4\}, \{5\}$</td>
      <td class="text-right">$+ \space number \space $$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    State 5 indicates that we should reduce using $expr \rightarrow expr \underline{+} \underline{number}$. And we can do that because $+$
    is in the follow set of $expr$. Thus, we pop off three elements from the stack and follow the
    "expr" transition out of state $\{0, 1, 2\}$.
  </p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}$</td>
      <td class="text-right">$+ \space number \space $$</td>
    </tr>
  </tbody>
</table>
<p>Like above, we can read &ldquo;+&rdquo; and &ldquo;number&rdquo; in succession. The state after reading the next two tokens is this.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}, \{4\}, \{5\}$</td>
      <td class="text-right">$\$$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>We are in state 5 and $\$$ is in the follow set of $expr$. We can thus reduce using $expr \rightarrow expr \underline{+} \underline{number}$
  by popping off three symbols and following $expr$ out of $\{0, 1, 2\}$</p>
</div>
<table>
  <thead>
    <tr>
      <th class="text-center">Stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}$</td>
      <td class="text-right">$\$$</td>
    </tr>
  </tbody>
</table>
<div>
  <p>
    Finally, we cannot do anything from state 7 but $\$$ is in the follow set of $expr'$ and so we can reduce using $expr' \rightarrow expr$. Since we
    have reduced the input string to $expr'$, we say that we have parsed the input successfully.
  </p>
</div>
<p>Let&rsquo;s compare the automaton framework that we just discussed with the stack framework that we discussed before. We can do a side-by-side comparison
of parsing &ldquo;number + number + number&rdquo; using addition grammar.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Automaton stack</th>
      <th class="text-center">Framework stack</th>
      <th class="text-center">Input</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="text-left">$\{0, 1, 2\}$</td>
      <td class="text-left"></td>
      <td class="text-right">$number + number + number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{6\}$</td>
      <td class="text-left">$number$</td>
      <td class="text-right">$+ \space number + number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}$</td>
      <td class="text-left">$expr$</td>
      <td class="text-right">$+ \space number + number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}, \{4\}$</td>
      <td class="text-left">$expr\space +$</td>
      <td class="text-right">$number + number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}, \{4\}, \{5\}$</td>
      <td class="text-left">$expr\space + number$</td>
      <td class="text-right">$+ \space number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}$</td>
      <td class="text-left">$expr$</td>
      <td class="text-right">$+ \space number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}, \{4\}$</td>
      <td class="text-left">$expr \space +$</td>
      <td class="text-right">$number\space $$</td>
    </tr>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}, \{4\}, \{5\}$</td>
      <td class="text-left">$expr \space + number$</td>
      <td class="text-right">$\$$</td>
    </tr>
    <tr>
      <td class="text-left">$\{0, 1, 2\}, \{3, 7\}$</td>
      <td class="text-left">$expr$</td>
      <td class="text-right">$\$$</td>
    </tr>
  </tbody>
</table>
<p><em>The symbols on the framework stack are exactly those that drive the automaton.</em> Hence, the automaton framework is equivalent to the
stack framework. And because the automaton is a directed graph, we can use the standard graph data structures and algorithms to implement it.</p>
<p>Let us try a slightly more complicated example. Here is the augmented addition and multiplication grammar.</p>
<div class="grammar-box">
  <p class="grammar-box-title">Augmented addition and multiplication</p>
  <p>Start symbol: expr'</p>
  $$
  \begin{align*}
    expr' & \rightarrow expr \\
    expr & \rightarrow expr \underline{+} term \\
    expr & \rightarrow term \\
    term & \rightarrow term \underline{*} f\!actor \\
    term & \rightarrow f\!actor \\
    f\!actor & \rightarrow \underline{number} \\
  \end{align*}
  $$
</div>
<div>
  <p>
    Here is the start state and its closure set. Remember that if there is a dot before a non terminal, we need to add $\epsilon$-transitions to all
    the productions of that non terminal. So we add $\epsilon$-transitions out of state 0 to the $expr$ productions, from state
    2 to $term$ productions, and from state 4 to $f\!actor$ productions.
  </p>
</div>
<p><img src="/img/compilers/grammar_add_mul_start_state.png" alt="Add mul start"></p>
<div>
  <p>
    In general, we can compute the $\epsilon$-closure of an item by doing a breadth first search on $\epsilon$-transitions. The algorithm looks
    like this
  </p>
</div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>compute_epsilon_closure(item, grammar):
</span></span><span style="display:flex;"><span>  epsilon_closure_set <span style="color:#f92672">=</span> {item}
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">.</span>enqueue(item)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> queue <span style="color:#f92672">is</span> non<span style="color:#f92672">-</span>empty {
</span></span><span style="display:flex;"><span>    current_item <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>dequeue()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> current_item has dot before a non terminal:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> production <span style="color:#f92672">in</span> productions of non terminal:
</span></span><span style="display:flex;"><span>        next_item <span style="color:#f92672">=</span> construct item <span style="color:#66d9ef">for</span> the production <span style="color:#66d9ef">with</span> dot on the left side of the body
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> next item <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> already <span style="color:#f92672">in</span> the epsilon closure set
</span></span><span style="display:flex;"><span>          epsilon_closure_set<span style="color:#f92672">.</span>add(next_item)
</span></span><span style="display:flex;"><span>          queue<span style="color:#f92672">.</span>enqueue(next_item)</span></span></code></pre></div>
<p>To make the illustrations concise, we collect all the items that belong to the same closure set into item sets. The above closure set
looks like this.</p>
<p><img src="/img/compilers/grammar_add_mul_start_state2.png" alt="Add mul start2"></p>
<div>
  <p>
    To figure out the states reachable from state 0, we check the symbols next to the dot for each item and make
    those transitions out. So for state 0, there will be four transitions, one each with label $expr$, $term$,
    $f\!actor$, and $number$. The states reachable from 0 look like this.
  </p>
</div>
<p><img src="/img/compilers/grammar_add_mul_bfs_step1.png" alt="Add mul bfs step1"></p>
<p>We can continue in breadth-first search fashion. Let us now look at the state 1. There is only one transition out of that state, the one with the label +.
We compute the epsilon closure of the new state; it looks like this.</p>
<p><img src="/img/compilers/grammar_add_mul_bfs_step2.png" alt="Add mul bfs step2"></p>
<p>Continuing with our breadth first search, we next look at state 2. There is one transition out of that state with label *.</p>
<p><img src="/img/compilers/grammar_add_mul_bfs_step3.png" alt="Add mul bfs step3"></p>
<p>We can keep expanding the transition graph using the breadth first search. The complete automaton looks like this.</p>
<p><img src="/img/compilers/grammar_add_mul_bfs_complete.png" alt="Add mul bfs complete"></p>
<p>The above graph can be represented by the following adjacency list.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0</span>: {<span style="color:#e6db74">&#34;expr&#34;</span>: <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;term&#34;</span>: <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">1</span>: {<span style="color:#e6db74">&#34;+&#34;</span>: <span style="color:#ae81ff">5</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2</span>: {<span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#ae81ff">6</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">5</span>: {<span style="color:#e6db74">&#34;term&#34;</span>: <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">6</span>: {<span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">7</span>: {<span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#ae81ff">6</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, there are some differences between directed graphs and the above automaton.</p>
<ol>
<li>When we reach a new state, we push that state on to the stack. That is, we do a shift.</li>
<li>When we reach a state where any of the items has the dot on the right side of the body, we do a reduce using that production, depending on the
next input token.</li>
</ol>
<p>We need to modify our above representation to handle shift and reduce actions. To support shift, we add a prefix &ldquo;s&rdquo; to each state that is the
result of a state and a transition symbol.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0</span>: {<span style="color:#e6db74">&#34;expr&#34;</span>: <span style="color:#e6db74">&#34;s1&#34;</span>, <span style="color:#e6db74">&#34;term&#34;</span>: <span style="color:#e6db74">&#34;s2&#34;</span>, <span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s3&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">1</span>: {<span style="color:#e6db74">&#34;+&#34;</span>: <span style="color:#e6db74">&#34;s5&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2</span>: {<span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;s6&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">5</span>: {<span style="color:#e6db74">&#34;term&#34;</span>: <span style="color:#e6db74">&#34;s7&#34;</span>, <span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s3&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">6</span>: {<span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s8&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">7</span>: {<span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;s6&#34;</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To add support for reduce, we first number all the productions so that we can refer to them.</p>
<div class="grammar-box">
  $$
  \begin{align*}
    1)\space & expr' \rightarrow expr \\
    2)\space & expr \rightarrow expr \underline{+} term \\
    3)\space & expr \rightarrow term \\
    4)\space & term \rightarrow term \underline{*} f\!actor \\
    5)\space & term \rightarrow f\!actor \\
    6)\space & f\!actor \rightarrow \underline{number} \\
  \end{align*}
  $$
</div>
<p>Next, we compute the follow set of each non terminal.</p>
<div>
  $$
  \begin{align*}
    & compute\_f\!ollow\_set(expr') = \{\$\} \\
    & compute\_f\!ollow\_set(expr) = \{+, \$\} \\
    & compute\_f\!ollow\_set(term) = \{+, *, \$\} \\
    & compute\_f\!ollow\_set(f\!actor) = \{+, *, \$\}
  \end{align*}
  $$
</div>
<div>
  <p>
    Let's take state 7 of the above automaton as an example. It has an item of production 2 with the dot on the right side of the production. 
    We do a reduce using production 2 if we are in state 7 and the next input token is either $+$ or $$$ which are in the follow set of $expr$.
    We add that information to our data structure by adding the entry "r2" for $(7, +)$ and $(7, $)$ in the automaton.
  </p>
</div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0</span>: {<span style="color:#e6db74">&#34;expr&#34;</span>: <span style="color:#e6db74">&#34;s1&#34;</span>, <span style="color:#e6db74">&#34;term&#34;</span>: <span style="color:#e6db74">&#34;s2&#34;</span>, <span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s3&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">1</span>: {<span style="color:#e6db74">&#34;+&#34;</span>: <span style="color:#e6db74">&#34;s5&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2</span>: {<span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;s6&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">5</span>: {<span style="color:#e6db74">&#34;term&#34;</span>: <span style="color:#e6db74">&#34;s7&#34;</span>, <span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s3&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">6</span>: {<span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s8&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">7</span>: {<span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;s6&#34;</span>,<span style="color:#e6db74">&#34;+&#34;</span>, <span style="color:#e6db74">&#34;r2&#34;</span>, <span style="color:#e6db74">&#34;$&#34;</span>, <span style="color:#e6db74">&#34;r2&#34;</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In general, to fill in the reduce moves in our above data structure, we need to do these things:</p>
<ol>
<li>We look at each state and select those that have at least one item with the dot on the right side.</li>
<li>For each symbol in the follow set of the head of the reducible item, we add entries for that state and that symbol for the correponding reduction.</li>
</ol>
<p>The above data structure called a <em>parsing table</em>. It can be constructed by doing a breadth first search.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">construct_parsing_table</span>(grammar):
</span></span><span style="display:flex;"><span>  productions_list <span style="color:#f92672">=</span> grammar<span style="color:#f92672">.</span>get_productions()
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  start_production <span style="color:#f92672">=</span> grammar<span style="color:#f92672">.</span>get_start_production()
</span></span><span style="display:flex;"><span>  start_item_set <span style="color:#f92672">=</span> construct_item_set(start_production)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">.</span>enqueue(start_production)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  parsing_table <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># BFS to compute shift moves.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> <span style="color:#960050;background-color:#1e0010">!</span>queue<span style="color:#f92672">.</span>empty():
</span></span><span style="display:flex;"><span>    current_state <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>dequeue()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> transition_symbol <span style="color:#f92672">in</span> current_state<span style="color:#f92672">.</span>get_transition_symbols():
</span></span><span style="display:flex;"><span>      next_state <span style="color:#f92672">=</span> current_state<span style="color:#f92672">.</span>compute_next_state(transition_symbol)
</span></span><span style="display:flex;"><span>      parsing_table<span style="color:#f92672">.</span>add_entry(current_state, transition_symbol, next_state)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Compute reduce moves by scanning all the states.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> item_set <span style="color:#f92672">in</span> all_item_sets():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> item_set<span style="color:#f92672">.</span>get_reducible_items():
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> item has dot on the right hand side: 
</span></span><span style="display:flex;"><span>        production <span style="color:#f92672">=</span> item<span style="color:#f92672">.</span>get_production()
</span></span><span style="display:flex;"><span>        production_head <span style="color:#f92672">=</span> production<span style="color:#f92672">.</span>get_head()
</span></span><span style="display:flex;"><span>        production_number <span style="color:#f92672">=</span> production<span style="color:#f92672">.</span>get_number()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> symbol <span style="color:#f92672">in</span> follow_set(production_head)
</span></span><span style="display:flex;"><span>          state <span style="color:#f92672">=</span> item_set<span style="color:#f92672">.</span>get_state()
</span></span><span style="display:flex;"><span>          parsing_table<span style="color:#f92672">.</span>add_entry(state, symbol, <span style="color:#e6db74">&#34;r production_number&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> parsing_table
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Using the above algorithm, the parsing table of the addition and multiplication grammar looks like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0</span>: {<span style="color:#e6db74">&#34;expr&#34;</span>: <span style="color:#e6db74">&#34;s1&#34;</span>, <span style="color:#e6db74">&#34;term&#34;</span>: <span style="color:#e6db74">&#34;s2&#34;</span>, <span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s3&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">1</span>: {<span style="color:#e6db74">&#34;+&#34;</span>: <span style="color:#e6db74">&#34;s5&#34;</span>, <span style="color:#e6db74">&#34;$&#34;</span>: <span style="color:#e6db74">&#34;r1&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2</span>: {<span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;s6&#34;</span>, <span style="color:#e6db74">&#34;+&#34;</span>: <span style="color:#e6db74">&#34;r3&#34;</span>, <span style="color:#e6db74">&#34;$&#34;</span>: <span style="color:#e6db74">&#34;r3&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">3</span>: {<span style="color:#e6db74">&#34;+&#34;</span>: <span style="color:#e6db74">&#34;r5&#34;</span>, <span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;r5&#34;</span>, <span style="color:#e6db74">&#34;$&#34;</span>: <span style="color:#e6db74">&#34;r5&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">4</span>: {<span style="color:#e6db74">&#34;+&#34;</span>: <span style="color:#e6db74">&#34;r6&#34;</span>, <span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;r6&#34;</span>, <span style="color:#e6db74">&#34;$&#34;</span>: <span style="color:#e6db74">&#34;r6&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">5</span>: {<span style="color:#e6db74">&#34;term&#34;</span>: <span style="color:#e6db74">&#34;s7&#34;</span>, <span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s3&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">6</span>: {<span style="color:#e6db74">&#34;factor&#34;</span>: <span style="color:#e6db74">&#34;s8&#34;</span>, <span style="color:#e6db74">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;s4&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">7</span>: {<span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;s6&#34;</span>, <span style="color:#e6db74">&#34;+&#34;</span>, <span style="color:#e6db74">&#34;r2&#34;</span>, <span style="color:#e6db74">&#34;$&#34;</span>, <span style="color:#e6db74">&#34;r2&#34;</span>},
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">8</span>: {<span style="color:#e6db74">&#34;+&#34;</span>: <span style="color:#e6db74">&#34;r4&#34;</span> <span style="color:#e6db74">&#34;*&#34;</span>: <span style="color:#e6db74">&#34;r4&#34;</span>, <span style="color:#e6db74">&#34;$&#34;</span>: <span style="color:#e6db74">&#34;r4&#34;</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let us do an example run of the above parsing table on the input &ldquo;number + number * number&rdquo;. We add a column for explanations.</p>
<table>
  <thead>
    <tr>
      <th class="text-center">Parser stack</th>
      <th class="text-center">Input</th>
      <th class="text-center">Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$0$</td>
      <td>$number + number * number \space $$</td>
      <td class="text-right">Shift $4$.</td>
    </tr>
    <tr>
      <td>$0, 4$</td>
      <td>$+ \space number * number \space $$</td>
      <td class="text-right">Reduce using production 6, $f\!actor \rightarrow \underline{number}$, and transition from $0$ on $f\!actor$.</td>
    </tr>
    <tr>
      <td>$0, 3$</td>
      <td>$+ \space number * number \space $$</td>
      <td class="text-right">Reduce using production 5, $term \rightarrow f\!actor$, and transition from $0$ on $term$.</td>
    </tr>
    <tr>
      <td>$0, 2$</td>
      <td>$+ \space number * number \space $$</td>
      <td class="text-right">Reduce using production 3, $expr \rightarrow term$, and transition from $0$ on $expr$.</td>
    </tr>
    <tr>
      <td>$0, 1$</td>
      <td>$+ \space number * number \space $$</td>
      <td class="text-right">Shift $5$.</td>
    </tr>
    <tr>
      <td>$0, 1, 5$</td>
      <td>$number * number \space $$</td>
      <td class="text-right">Shift $4$.</td>
    </tr>
    <tr>
      <td>$0, 1, 5, 4$</td>
      <td>$*\space number \space $$</td>
      <td class="text-right">Reduce using production 6, $f\!actor \rightarrow \underline{number}$, and transition from state $5$ on $f\!actor$.</td>
    </tr>
    <tr>
      <td>$0, 1, 5, 3$</td>
      <td>$*\space number \space $$</td>
      <td class="text-right">Reduce using production 5, $term \rightarrow f\!actor$, and transition from state $5$ on $term$.</td>
    </tr>
    <tr>
      <td>$0, 1, 5, 7$</td>
      <td>$*\space number \space $$</td>
      <td class="text-right">Shift $6$.</td>
    </tr>
    <tr>
      <td>$0, 1, 5, 7, 6$</td>
      <td>$number \space $$</td>
      <td class="text-right">Shift $4$.</td>
    </tr>
    <tr>
      <td>$0, 1, 5, 7, 6, 4$</td>
      <td>$\$$</td>
      <td class="text-right">Reduce using production 6, $f\!actor \rightarrow \underline{number}$, and transition from state $6$ on $f\!actor$.</td>
    </tr>
    <tr>
      <td>$0, 1, 5, 7, 6, 8$</td>
      <td>$\$$</td>
      <td class="text-right">Reduce using production 4, $term \rightarrow term \underline{*} f\!actor$, and transition from state $5$ on $term$.</td>
    </tr>
    <tr>
      <td>$0, 1, 5, 7$</td>
      <td>$\$$</td>
      <td class="text-right">Reduce using production 2, $expr \rightarrow expr \underline{+} term$, and transition from state $0$ on $expr$.</td>
    </tr>
    <tr>
      <td>$0, 1$</td>
      <td>$\$$</td>
      <td class="text-right">Reduce using production 1, $expr' \rightarrow expr$, and accept.</td>
    </tr>
  </tbody>
</table>
<p>Notice that all the information we need to make parsing moves is contained in the parsing table. We no longer need to look at a production list or
follow sets to execute parsing actions. We thus have solved the main problem we were pursuing. Parsing tables are the implementations for context-free
grammars.</p>
<h2 id="conclusion">Conclusion</h2>
<p>What is the output of a parser? We can return a boolean indicating whether the input is parseable. But we need to return more information. Specifically, the
reduce moves we did might be interesting to the later phases of the compiler.</p>
<p>We need to define more concepts before we can discuss the output of a parser. Specifically, we need to execute actions whenever a reduction happens.
This subject will be treated in the next article.</p>
</section>

  
  

  
  
  
  
  <nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  >
    
    <a class="ltr:pr-3 rtl:pl-3" href="http://saurabhjha.github.io/posts/2021-06-06-basic-blocks/"
      ><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Constructing basic blocks</span></a
    >
    
    
    <a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href="http://saurabhjha.github.io/posts/2020-06-12-implementing-regular-expressions/"
      ><span>Implementing regular expressions</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>
  </body>
</html>
