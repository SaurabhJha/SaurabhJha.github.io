<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Saurabh Jha</title>
    <link>https://saurabhjha.github.io/</link>
    <description>Recent content on Saurabh Jha</description>
    <generator>Hugo</generator>
    <language>en-gb</language>
    <lastBuildDate>Mon, 02 May 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://saurabhjha.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Expressing LU factorization using rank one matrices</title>
      <link>https://saurabhjha.github.io/posts/2022-05-02-lu-rank-one/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2022-05-02-lu-rank-one/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://saurabhjha.github.io/posts/2022-01-03-matrix-multiplication-rank-one/&#34;&gt;last article&lt;/a&gt;, we looked at expressing matrix multiplication using rank one matrices. In this article, we will study LU factorization using rank one matrices.&lt;/p&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;We are assuming that you are familiar with linear algebra corresponding to a typical undergrad course. In particular, we are assuming that you are familiar with Gaussian elimination and LU factorization.&lt;/p&gt;&#xA;&lt;h2 id=&#34;running-example&#34;&gt;Running example&lt;/h2&gt;&#xA;&lt;p&gt;In LU factorization, we take a square matrix and turn it into an upper triangular matrix. As our running example, we will look at the following matrix. Let&amp;rsquo;s turn it into an upper triangular matrix using a sequence of row operations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Expressing matrix multiplications using rank one matrices</title>
      <link>https://saurabhjha.github.io/posts/2022-01-03-matrix-multiplication-rank-one/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2022-01-03-matrix-multiplication-rank-one/</guid>
      <description>&lt;p&gt;Matrix multiplication is a fundamental operation in many areas of computer science. In this article, we will explore a new technique of doing matrix multiplications. We will first get some intuition by going through some examples. We will then formally prove that the new technique gives the same result as the standard matrix multiplication. Finally, we will discuss its possible applications.&lt;/p&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;I am assuming that you are familiar with linear algebra corresponding to a typical undergrad course. In particular, I make use of addition between matrices, multiplication between matrices, and the concept of the rank of a matrix.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Constructing basic blocks</title>
      <link>https://saurabhjha.github.io/posts/2021-06-06-basic-blocks/</link>
      <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2021-06-06-basic-blocks/</guid>
      <description>&lt;p&gt;&lt;em&gt;In this article, we cover concepts from the &lt;a href=&#34;https://www.cs.cornell.edu/courses/cs6120/2020fa/lesson/2/&#34;&gt;second lesson&lt;/a&gt; of the &lt;a href=&#34;https://www.cs.cornell.edu/courses/cs6120/2020fa/self-guided/&#34;&gt;advanced compilers course&lt;/a&gt; from Cornell. However, the specific algorithms discussed in this article are different from the ones discussed in the course.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;To execute a program written in a high level-language, we first need to translate it into a processor-specific machine language program. One way to do&#xA;this is to first translate the program text into a data structure. We can then use that data structure to generate a machine language program. These&#xA;intermediary data structures are called intermediate representations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Implementing parsers</title>
      <link>https://saurabhjha.github.io/posts/2020-07-21-implementing-parser-generators/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2020-07-21-implementing-parser-generators/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Once we have tokenized some program text, we need to check whether the tokens are in the correct sequence. For example, which of the following token&#xA;sequences are valid?&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Tokenization of &amp;ldquo;32 + 4&amp;rdquo;: &amp;ldquo;&amp;lt;number, 32&amp;gt;, &amp;lt;+, +&amp;gt;, &amp;lt;number, 4&amp;gt;&amp;rdquo;.&lt;/li&gt;&#xA;&lt;li&gt;Tokenization of &amp;ldquo;+ 32 4&amp;rdquo;: &amp;ldquo;&amp;lt;+, +&amp;gt;, &amp;lt;number, 32&amp;gt;, &amp;lt;number, 4&amp;gt;&amp;rdquo;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Regular expressions are not powerful enough to make the choices like these.  The rules about which token sequences are valid constitute the&#xA;&lt;em&gt;syntax&lt;/em&gt; of a programming language. In this article, we will develop the concepts and techniques of checking syntactic correctness of a program&#xA;text.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Implementing regular expressions</title>
      <link>https://saurabhjha.github.io/posts/2020-06-12-implementing-regular-expressions/</link>
      <pubDate>Fri, 12 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2020-06-12-implementing-regular-expressions/</guid>
      <description>&lt;p&gt;The first thing we do when we try to understand some program text is to divide it. For example, &amp;ldquo;12 + 34&amp;rdquo; can be divided into &amp;ldquo;12&amp;rdquo;, &amp;ldquo;+&amp;rdquo;, and &amp;ldquo;34&amp;rdquo;.&#xA;If we want to include spaces, we can divide them as &amp;ldquo;12&amp;rdquo;, &amp;quot; &amp;ldquo;, &amp;ldquo;+&amp;rdquo;, &amp;quot; &amp;ldquo;, and &amp;ldquo;34&amp;rdquo;. Or if we are crazy, we can divide them as &amp;ldquo;12 +&amp;rdquo; and &amp;ldquo;34&amp;rdquo;.&lt;/p&gt;&#xA;&lt;p&gt;The program texts are represented as strings. Before dividing a string, we need to decide on the rules for dividing. One set of rules can be we only&#xA;care about numbers and the &amp;ldquo;+&amp;rdquo; sign. In that case, the valid substrings are &amp;ldquo;12&amp;rdquo;, &amp;ldquo;+&amp;rdquo;, and &amp;ldquo;34&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A parser for an array language</title>
      <link>https://saurabhjha.github.io/posts/2020-03-22-a-parser-for-an-array-language/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2020-03-22-a-parser-for-an-array-language/</guid>
      <description>&lt;p&gt;In my previous &lt;a href=&#34;https://saurabhjha.github.io/posts/2020-02-22-problem-implicit-parallelism-array-languages/&#34; title=&#34;Problem: Implicit parallelism in array languages&#34;&gt;post&lt;/a&gt;&#xA;, we stated that the goal is to use an array language to explore the problems of implicit parallelism. To get started&#xA;with that, we need an infrastructure on which we can test our ideas. Specifically, we need to design and implement&#xA;an array language before we can tangibly do anything.&lt;/p&gt;&#xA;&lt;p&gt;We are going to start easy and add features as we go along. In particular, we should keep reminding ourselves that we are not making a&#xA;product to be shipped but a prototype to evaluate our hypotheses. It&amp;rsquo;s a means to an end, in particular, the compiler we are building&#xA;is a means to evaluate parallelism and nothing else.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Problem: Implicit parallelism in array languages</title>
      <link>https://saurabhjha.github.io/posts/2020-02-22-problem-implicit-parallelism-array-languages/</link>
      <pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2020-02-22-problem-implicit-parallelism-array-languages/</guid>
      <description>&lt;p&gt;Over the past several weeks, I have been thinking about this problem: if we have a programming&#xA;language where the only permissible data type is an array, can we implicitly parallelize&#xA;that? The idea of implicit parallelism, as I understand it, is that the compiler automatically creates&#xA;threads and maps those to the program without the programmer specifying it.&lt;/p&gt;&#xA;&lt;p&gt;This can become an important problem because of the current trends in processor hardware. The fact is&#xA;that in the last decade, the processor industry has increased the processor speed by adding more&#xA;processing cores to their chips. So a language that can better exploit this parallelism will be faster&#xA;in execution time, all other things being equal.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Review: The Structure of the &#34;THE&#34; Multiprogramming System</title>
      <link>https://saurabhjha.github.io/posts/2017-11-11-paper-review-the-structure-of-the-the-multiprogramming-system/</link>
      <pubDate>Sat, 11 Nov 2017 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2017-11-11-paper-review-the-structure-of-the-the-multiprogramming-system/</guid>
      <description>&lt;p&gt;This paper was written by the great Edsger Dijkstra. Before reviewing it, I&#xA;should point out a couple of quick facts:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;It was published in SOSP 1967.&lt;/li&gt;&#xA;&lt;li&gt;It predates UNIX and C.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;This paper describes a multiprogramming system named &amp;ldquo;THE&amp;rdquo;. It&amp;rsquo;s main&#xA;contributions are:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A demonstration of the concept of software layering and how it leads to better verification&#xA;and testing of a system.&lt;/li&gt;&#xA;&lt;li&gt;The idea of software page-based virtual memory.&lt;/li&gt;&#xA;&lt;li&gt;The idea of semaphore for use in concurrency.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;This paper is about fifty years old. I will try to describe it in&#xA;today&amp;rsquo;s terminology rather than using terms like &amp;ldquo;core memory&amp;rdquo;, &amp;ldquo;drum memory&amp;rdquo;&#xA;and so on.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Review: End-to-end Arguments in System Design</title>
      <link>https://saurabhjha.github.io/posts/2017-11-07-paper-review-end-to-end-arguments-in-system-design/</link>
      <pubDate>Tue, 07 Nov 2017 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2017-11-07-paper-review-end-to-end-arguments-in-system-design/</guid>
      <description>&lt;p&gt;These are my thoughts on the classic paper &amp;ldquo;End-to-end Arguments in System&#xA;Design&amp;rdquo; written by Jerome Saltzer, David Reed, and David Clarke. It&amp;rsquo;s a very old&#xA;paper; the version I read was published in 1984. The paper argues against&#xA;implementing functionality at lower levels of the system. It appeals to&#xA;application requirements and argues for moving a function upwards in a layered&#xA;system.&lt;/p&gt;&#xA;&lt;p&gt;I believe these ideas started gaining more ground after the advent of networked&#xA;computers. The concept is motivated using examples from data communication&#xA;networks and transactional systems.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Learning to write concurrent programs</title>
      <link>https://saurabhjha.github.io/posts/2017-03-14-learning-to-write-concurrent-programs/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2017-03-14-learning-to-write-concurrent-programs/</guid>
      <description>&lt;p&gt;I taught myself some concurrent programming lately. I did it as part of my&#xA;operating systems studies. In this essay, I will illustrate it using an&#xA;example problem.&lt;/p&gt;&#xA;&lt;p&gt;I will be illustrating concurrent programming using operating system primitives.&#xA;[1] There are several different ways to do concurrent programming that does&#xA;not involve interacting with the operating system kernel. Even if we restrict&#xA;ourselves to using kernel primitives, there are many variants. I will&#xA;mainly be concerned with concurrency using mutexes and condition variables. In&#xA;literature, it is sometimes called &lt;em&gt;concurrent programming using shared objects&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>DevOps from a noob&#39;s perspective</title>
      <link>https://saurabhjha.github.io/posts/2016-12-13-devops-from-noobs-perspective/</link>
      <pubDate>Tue, 13 Dec 2016 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2016-12-13-devops-from-noobs-perspective/</guid>
      <description>&lt;p&gt;I am involved in some official project where I got a chance to set up web&#xA;infrastructure. This was the first time I did any kind of system&#xA;administration work so it has been an adventure.&lt;/p&gt;&#xA;&lt;p&gt;Here are some lessons I learned as I did and continue to do this work.&lt;/p&gt;&#xA;&lt;h2 id=&#34;read-the-fine-manual-rtfm&#34;&gt;Read the fine manual (RTFM)&lt;/h2&gt;&#xA;&lt;p&gt;Be ready to invest lots of time reading up documentation. For web applications:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Read up on your hosting provider and how network security works.&lt;/li&gt;&#xA;&lt;li&gt;Read up on servers (web/proxy/database) you are using and how&#xA;they handle requests.&lt;/li&gt;&#xA;&lt;li&gt;Read up on storage components you are administering like database&#xA;servers.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Having this knowledge handy can make recovery easier and less stressful.&#xA;For example, data errors are especially costly and a bug might make you&#xA;desperate as you are looking for some magical band-aid on StackOverflow&#xA;in the middle of an outage.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Writing a command shell</title>
      <link>https://saurabhjha.github.io/posts/2016-05-08-writing-a-command-shell/</link>
      <pubDate>Sun, 08 May 2016 00:00:00 +0000</pubDate>
      <guid>https://saurabhjha.github.io/posts/2016-05-08-writing-a-command-shell/</guid>
      <description>&lt;p&gt;I got interested in systems programming due to an assignment at work that&#xA;involved sockets. I got curious about what could be happening behind such an&#xA;interface.&lt;/p&gt;&#xA;&lt;p&gt;I started studying the python interface to sockets. It was very high level and&#xA;I did not learn much. So, I started studying the UNIX interface. With UNIX, I got overwhelmed&#xA;and painfully realized that I won&amp;rsquo;t be able to understand it unless I know how operating&#xA;systems work. I began my long quest towards learning how low-level things work.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
